<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DoubleWing&#39;Blog</title>
  <icon>https://www.gravatar.com/avatar/f69ff1ffbe594409dfb6e458b56c16a0</icon>
  <subtitle>喜欢就坚持吧！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DoubleWing/DoubleWing.github.io/"/>
  <updated>2019-10-30T09:38:24.526Z</updated>
  <id>https://github.com/DoubleWing/DoubleWing.github.io/</id>
  
  <author>
    <name>张昭</name>
    <email>1318911702@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大数据Hadoop的环境搭建及应用实践（*毕业设计*）（1）</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/42229cfc/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/42229cfc/</id>
    <published>2019-10-29T08:25:27.000Z</published>
    <updated>2019-10-30T09:38:24.526Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang编写聊天小程序demo</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/cf527c99/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/cf527c99/</id>
    <published>2019-10-29T08:19:56.000Z</published>
    <updated>2019-10-30T09:38:24.524Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go的http标准库</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/8b4fc6ac/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/8b4fc6ac/</id>
    <published>2019-10-27T09:42:06.000Z</published>
    <updated>2019-10-27T09:43:35.331Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>goroutine（一）</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/ef415e9f/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/ef415e9f/</id>
    <published>2019-10-27T09:38:33.000Z</published>
    <updated>2019-10-27T09:43:35.330Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go的资源管理与出错处理</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/77741060/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/77741060/</id>
    <published>2019-10-27T09:36:26.000Z</published>
    <updated>2019-10-27T09:43:35.328Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker初步使用及命令</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/d33e3198/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/d33e3198/</id>
    <published>2019-10-27T09:27:14.000Z</published>
    <updated>2019-10-27T09:43:35.327Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单理解Docker和Kubernetes</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/9afe7030/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/9afe7030/</id>
    <published>2019-10-27T09:26:36.000Z</published>
    <updated>2019-10-27T09:43:35.332Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/undefined/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/undefined/</id>
    <published>2019-10-21T05:55:33.000Z</published>
    <updated>2019-10-21T06:31:37.723Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%A0%91/"/>
    
      <category term="查找算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>B+树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/17426722/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/17426722/</id>
    <published>2019-10-21T05:55:06.000Z</published>
    <updated>2019-10-21T06:31:06.269Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%A0%91/"/>
    
      <category term="查找算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>B树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/9439fc83/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/9439fc83/</id>
    <published>2019-10-21T05:54:44.000Z</published>
    <updated>2019-10-30T09:37:43.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B树（多路查找树）"><a href="#B树（多路查找树）" class="headerlink" title="B树（多路查找树）"></a>B树（多路查找树）</h1><p>B树（B-tree）是一种平衡的多路查找树。节点最大的孩子数目称为B树的阶（order）</p><h2 id="B树的结构"><a href="#B树的结构" class="headerlink" title="B树的结构"></a>B树的结构</h2><ul><li>如果根节点不是叶子节点，则其至少有两棵子树</li><li>每一个非根节点的分支节点都有k-1个元素和k个孩子，其中[m/2]<= k <="m.<br">每一个叶子节点n都有k-1个元素，其中[m/2]<= k <="m</li"><li>所以叶子节点都位于同一层次</li><li>所有分支节点包含下列信息数据（n，A0,K1,A1,K2….,Kn，An）为关键字</li></=></=></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;B树（多路查找树）&quot;&gt;&lt;a href=&quot;#B树（多路查找树）&quot; class=&quot;headerlink&quot; title=&quot;B树（多路查找树）&quot;&gt;&lt;/a&gt;B树（多路查找树）&lt;/h1&gt;&lt;p&gt;B树（B-tree）是一种平衡的多路查找树。节点最大的孩子数目称为B树的阶（orde
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
      <category term="树" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/e5052ecb/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/e5052ecb/</id>
    <published>2019-10-21T05:53:41.000Z</published>
    <updated>2019-10-29T09:51:10.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a><em>二叉排序树</em></h1><p>二叉排序树（Binary Sort Tree）,又叫二叉查找树。<br>它是一棵空树或者是具有以下性质的数</p><ul><li>左子树不为空，左子树所有节点的值均小于自身根节点的值</li><li>右子树不为空，右子树所有节点的值均大于自身根节点的值</li><li>左右子树也是二叉排序树</li></ul><h1 id="二叉排序树-查找"><a href="#二叉排序树-查找" class="headerlink" title="二叉排序树-查找"></a>二叉排序树-查找</h1><ul><li>递归查找二叉排序树</li><li>若查找成功则指针指向该元素节点true</li><li>否则指针指向查找路径上访问的最后一个节点返回false</li></ul><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SearchBST为递归函数,lchild为左孩子,rchild为右孩子</span><br><span class="line"></span><br><span class="line">Status SearchBST(BiTree T,int key,BiTree f,BiTree *p){</span><br><span class="line">    if(!T)</span><br><span class="line">    {</span><br><span class="line">        *p = f;</span><br><span class="line">        return FALSE;</span><br><span class="line">    }</span><br><span class="line">    else if (key==T->data){</span><br><span class="line">        *p = T;</span><br><span class="line">        return TRUE;</span><br><span class="line">    }</span><br><span class="line">    else if (key<T->data){</T-></span><br><span class="line">        return SearchBST(T->lchild,key,T,p);</span><br><span class="line">    else</span><br><span class="line">        return SearchBST(T->rchild,key,T,p);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><ul><li>二叉排序树的查找运用了构造二叉树的特性，节点中满足一定的次序关系即：左子树节点一定比其双亲节点小，右子树节点一定比其双亲节点大</li><li>最少查找为1</li><li>最多查找为二叉排序树的深度</li><li>二叉排序树的查找性能取决于二叉排序树的形状（深度）  </li></ul><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉排序树&quot;&gt;&lt;a href=&quot;#二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树&quot;&gt;&lt;/a&gt;&lt;em&gt;二叉排序树&lt;/em&gt;&lt;/h1&gt;&lt;p&gt;二叉排序树（Binary Sort Tree）,又叫二叉查找树。&lt;br&gt;它是一棵空树或者是具有以下
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%A0%91/"/>
    
      <category term="查找算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>折半查找</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/8dbf9480/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/8dbf9480/</id>
    <published>2019-10-21T05:52:53.000Z</published>
    <updated>2019-10-29T09:08:27.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a><em>折半查找</em></h1><p>折半查找（Binary Search）技术，又称为二分查找，其前提是线性表中的记录有序，线性表必须采用线性存储。</p><h1 id="折半查找的思想"><a href="#折半查找的思想" class="headerlink" title="折半查找的思想"></a>折半查找的思想</h1><ul><li>取中间数字作为比较对象，若给定值与中间记录的关键字相等，则查找成功；</li><li>若给定值小于中间数字，则在左半区进行查找；</li><li>若给定值大于中间记录的关键字，则在右半区进行查找  </li><li>不断重复上述步骤，直到找到——查找成功或查找区域无记录——查找失败<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int Binary_Search(int *a,int n, int key){</span><br><span class="line">    int low ,high,mid;</span><br><span class="line">    low =l;</span><br><span class="line">    high = n;</span><br><span class="line">    while(lwo<=high){< span><br><span class="line">        mid = (low+high) /2;</span><br><span class="line">        if(key<a[mid])< span><br><span class="line">            high=mid-1；</span><br><span class="line">        else if (key>a[mid])</span><br><span class="line">            low=mid+1;</span><br><span class="line">        else </span><br><span class="line">            return mid;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></a[mid])<></span></=high){<></span></pre></td></tr></tbody></table></figure></li></ul><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><ul><li>将这个有序数组转化为二叉树，也就是说折半查找把一棵树分为两棵子树</li><li>只需要查找其中一个子树，等同于工作量少了一半，再继续拆分成两个子树，工作量少了一半</li><li>最好的情况一定是1次直接查找到，最坏是查找[log2^n]+1次</li></ul><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;折半查找&quot;&gt;&lt;a href=&quot;#折半查找&quot; class=&quot;headerlink&quot; title=&quot;折半查找&quot;&gt;&lt;/a&gt;&lt;em&gt;折半查找&lt;/em&gt;&lt;/h1&gt;&lt;p&gt;折半查找（Binary Search）技术，又称为二分查找，其前提是线性表中的记录有序，线性表必须采用线性
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
      <category term="线性表" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>顺序查找</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/cc0ea54c/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/cc0ea54c/</id>
    <published>2019-10-21T05:52:07.000Z</published>
    <updated>2019-10-29T09:13:44.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>顺序查找（Sequential Search）又叫做线性查找，是基本的查找技术</p><h1 id="线性查找的思想"><a href="#线性查找的思想" class="headerlink" title="线性查找的思想"></a>线性查找的思想</h1><ul><li>从表开始的第一个或最后一个开始，逐个进行记录的关键字和给与的定值进行比较</li><li>若相同，则查找成功</li><li>若遍历全表全部不同则查找失败</li></ul><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*a为数组，n为查找的数组长度，key为查找的关键字*/</span><br><span class="line"></span><br><span class="line">int Sequential Search(int *a,int n,int key){</span><br><span class="line">    int i;</span><br><span class="line">    for(i=1;i<=n;i++){< span><br><span class="line">        if (a[i]==key)</span><br><span class="line">            return i;</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></=n;i++){<></span></pre></td></tr></tbody></table></figure><h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p>每次循环都会去处理i是否越界，可以使用“驻点”免去i的判断具体代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int Sequential_Search2(int *a,int n,int key){</span><br><span class="line">    int i;</span><br><span class="line">    a[0]=key;</span><br><span class="line">    i=n;</span><br><span class="line">    while(a[i]!=key){</span><br><span class="line">        i--;</span><br><span class="line">    }</span><br><span class="line">    return i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>放置驻点可以在数据量多时免去i的判断提升效率。</p><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><ul><li>顺序查找算法有非常大的缺点，查找的效率低下，但是当对于小数据查找时也非常适用</li><li>顺序查找最好的时间复杂度即是1，第一个位置就找到</li><li>最坏的查找时间复杂度是最后一个位置，为O（n）  </li></ul><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顺序查找&quot;&gt;&lt;a href=&quot;#顺序查找&quot; class=&quot;headerlink&quot; title=&quot;顺序查找&quot;&gt;&lt;/a&gt;顺序查找&lt;/h1&gt;&lt;p&gt;顺序查找（Sequential Search）又叫做线性查找，是基本的查找技术&lt;/p&gt;
&lt;h1 id=&quot;线性查找的思想&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
      <category term="线性表" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>较复杂的排序算法</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/d20d6597/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/d20d6597/</id>
    <published>2019-10-21T04:25:27.000Z</published>
    <updated>2019-10-21T07:57:40.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交换类排序-快速排序"><a href="#交换类排序-快速排序" class="headerlink" title="交换类排序-快速排序"></a>交换类排序-快速排序</h1><p>可以理解为划分交换排序几乎最快的排序方法。（分治的策略）</p><h2 id="分治法的基本思想"><a href="#分治法的基本思想" class="headerlink" title="分治法的基本思想"></a>分治法的基本思想</h2><p>将原有问题分解为若干个规模更小但结构与原问题相似的自问题，递归地解决这些子问题，然后<br>将这些子问题的解组合为原问题的解</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>从一个待排序列中任意选择一个记录</li><li>以该记录的关键字作为“枢纽”</li><li>凡是关键字小于枢纽的记录均移动至该记录之前；反之，移动至该记录之后</li><li>一趟排序后，分割成左右两个子序列，再对两个子序列中进行快排 </li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int QKpass(RecordList L,int low,int high){</span><br><span class="line">    L.r[0] = L.r[low];</span><br><span class="line">    while(low<high){< span><br><span class="line">        while(low<high && l.r[high].key>=L.r[0].key){</high></span><br><span class="line">            --high;</span><br><span class="line">        }</span><br><span class="line">        L.r[low] = L.r[high] ;</span><br><span class="line">        while(low<high && l.r[low].key<l.r[0].key){< span><br><span class="line">            ++low;</span><br><span class="line">        }</span><br><span class="line">        L.r[high] = L.r[low] ;</span><br><span class="line">    }</span><br><span class="line">    L.r[low] = L.r[0];</span><br><span class="line">    return low;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void QKSort(RecordList L,int low, int high){</span><br><span class="line">    if(low>high){</span><br><span class="line">        pos=QKpass(L,low,high);</span><br><span class="line">        QKSort(L,low,pos-1);</span><br><span class="line">        QKSort(l,POS+1,high);</span><br><span class="line">    }</span><br><span class="line">}</span><br></high></span></high){<></span></pre></td></tr></tbody></table></figure><blockquote><p>输出结果：无  </p></blockquote><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>快排的时间代价一般取决于枢纽的选择  </li><li>最简单的办法是选取第一个或最后一个元素作为枢纽，但也是最差的情况，因为总是一个序列是为空，时间复杂度为O（n^2）  </li><li>可以选取中间位置（low+high）/2作为记录关键字的枢纽值，可以有效平分，最好的情况每次都分为长度相同的子序列，其时间复杂度为O（nlog以二为底的n次方) </li><li>快速排序每次移动记录跨度比较大，所以快排是不稳定的  </li></ul><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均复杂度</th><th style="text-align:center">空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(nlog2n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(nlog2n)</td><td style="text-align:center">O(nlog2n)</td><td>不稳定</td></tr></tbody></table><hr><hr><h1 id="选择类排序-堆排序"><a href="#选择类排序-堆排序" class="headerlink" title="选择类排序-堆排序"></a>选择类排序-堆排序</h1><p>为了弥补树形选择排序占用较多辅助空间的问题，利用堆的特性进行排序的方法</p><h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><p>堆是满足下列性质的数列：<br>将数列看成一颗完全二叉树，则堆或是空树或是满足下列特性的完全二叉树：<br>其左、右子树分别是堆，并且当左右子树不空时，根节点的值小于（或大于）左右子树根节点的值。</p><h2 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>首先将待排序的无序序列建初始小顶堆：堆顶元素为最小值</li><li>然后将堆顶记录和堆尾记录交换，并将最后一个记录的枝剪掉</li><li>调整剩余的记录序列，利用筛选法重新调整为一个新堆，堆顶元素为次最小值，然后交换并剪枝</li><li>进行n-1次操作后，直到所有元素输出的元素为一个有序序列 </li></ul><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//堆的筛选</span><br><span class="line">void heapAdjust(RecordList L,int s,int m){</span><br><span class="line">    //调整L.r[s]的关键字，使L.s[s..m]成为一个小顶堆</span><br><span class="line">    t = L.r[s];</span><br><span class="line">    for(j=2*s;j<=m;j*=2){< span><br><span class="line">        //沿key较小的孩子结点向下筛选</span><br><span class="line">        if(j<m && l.r[j].key>L.r[j+1].key){</m></span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        if(t.key<=L.r[j].key){< span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">        //t应插入在位置s上</span><br><span class="line">        L.r[s] = L.r[j];</span><br><span class="line">        s= j;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    L.r[s]=t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//建初始堆</span><br><span class="line">void CreatHeap(RecordList L){</span><br><span class="line">    for(i=L.length/2;i>=1;i--){</span><br><span class="line">        HeapAdjust(L,i,L.length);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//堆排序</span><br><span class="line">void HeapSort(RecordList L){</span><br><span class="line">    CreatHeap(L);</span><br><span class="line">    for(i=L.length;i>=2;i--){</span><br><span class="line">        L.r[0] = L.r[1];</span><br><span class="line">        L.r[1] = L.r[i];</span><br><span class="line">        L.r[i] = L.r[0];</span><br><span class="line">        HeapAdjust(L,1,i-1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></=L.r[j].key){<></span></=m;j*=2){<></span></pre></td></tr></tbody></table></figure><blockquote><p>输出结果：无  </p></blockquote><h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>堆排序主要花费在建初始堆和调整建新堆反复的筛选上  </li><li>对于深度为k的堆，筛选中关键字的比较次数最多为2(k-1)次。堆排序的时间复杂度为O（nlog2n） </li><li>只需要一个辅助空间，故空间复杂度为O（1）</li><li>堆排序仍然是大跨度调整了元素位置，为不稳定的排序  </li></ul><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均复杂度</th><th style="text-align:center">空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(nlog2n)</td><td style="text-align:center">O(nlog2n)</td><td style="text-align:center">O(nlog2n)</td><td style="text-align:center">O(1)</td><td>不稳定</td></tr></tbody></table><hr><hr><h1 id="归并类排序-二路归并排序"><a href="#归并类排序-二路归并排序" class="headerlink" title="归并类排序-二路归并排序"></a>归并类排序-二路归并排序</h1><h1 id="分配类排序-链式基数排序"><a href="#分配类排序-链式基数排序" class="headerlink" title="分配类排序-链式基数排序"></a>分配类排序-链式基数排序</h1><h1 id="外部排序-置换选择排序"><a href="#外部排序-置换选择排序" class="headerlink" title="外部排序-置换选择排序"></a>外部排序-置换选择排序</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;交换类排序-快速排序&quot;&gt;&lt;a href=&quot;#交换类排序-快速排序&quot; class=&quot;headerlink&quot; title=&quot;交换类排序-快速排序&quot;&gt;&lt;/a&gt;交换类排序-快速排序&lt;/h1&gt;&lt;p&gt;可以理解为划分交换排序几乎最快的排序方法。（分治的策略）&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是uipath</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/ed117eeb/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/ed117eeb/</id>
    <published>2019-10-21T03:12:26.000Z</published>
    <updated>2019-10-21T04:17:01.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UiPath"><a href="#UiPath" class="headerlink" title="UiPath"></a>UiPath</h1><p>一家机器人自动化的国际大公司，旗下产品uipath studio、uipath center、uipath robot都是关于RPA流程开发的工具</p><h2 id="了解途径"><a href="#了解途径" class="headerlink" title="了解途径"></a>了解途径</h2><p>前几日，在36氪上看到前沿信息机器人自动化等等，觉得高大上，感觉是Al的落实项目，<br>随机开始搜索信息关注此行业，从官网到QQ群到微信群再到论坛，无疑此为新型的行业，但是运用的是无编程技术主要是对于业务的了解情况以及思维逻辑和流程图设计，应该划分为业务部分。</p><h1 id="uipath-架构"><a href="#uipath-架构" class="headerlink" title="uipath 架构"></a>uipath 架构</h1><p>打开uipath官网  ，了解其架构体系为：</p><ul><li><p>Studio（编辑器）—— 如各个编译平台一样，uipathStudio 是RPA流程开发工具</p></li><li><p>Ochestrator（中控/web平台）—— 管理所有的流程机器人、以及报表显示，及其他远程控制操作 类似阿里云平台</p></li><li><p>RoBots（机器人（脚本））——机器人安装到不同的电脑中，直接运行开发好的RPA流程，<br>（有两种触发方式<br>1.人机互动，手动才能触发<br>2.VM虚拟机中固定时间自动触发）</p></li></ul><h1 id="应用于"><a href="#应用于" class="headerlink" title="应用于"></a>应用于</h1><ul><li>金融行业（繁杂的业务逻辑，使用简单的机器人代替人工是不错的方案）</li><li>系统陈旧的企业（通过机器人完成业务逻辑，节约再开发再更新的成本）</li></ul><h1 id="国外RPA厂商"><a href="#国外RPA厂商" class="headerlink" title="国外RPA厂商"></a>国外RPA厂商</h1><p>uipath、buleprime、AA（简写）、NICE等</p><h2 id="国内厂商"><a href="#国内厂商" class="headerlink" title="国内厂商"></a>国内厂商</h2><p>艺赛旗、UiBot、达观数据等</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过三天的学习和探索，考取了uibot的认证工程师（其实是20分钟，不需要编程能力（笑），我认为这个行业对于计算机专业的专业编程人员来说不是一种系统学习知识的过程，其中是Excel、VBA、Python、Java、数据库、网络的零星知识点大集合，其中大量的业务逻辑用在UI自动化上，所以根据自己的学习路线应该了解uipath前沿信息，其技能很有可能人人都会用提前了解一下，要去真正的学习有门槛有难度的技术类似于AL、人工智能（我并不认为我能学会（哭）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UiPath&quot;&gt;&lt;a href=&quot;#UiPath&quot; class=&quot;headerlink&quot; title=&quot;UiPath&quot;&gt;&lt;/a&gt;UiPath&lt;/h1&gt;&lt;p&gt;一家机器人自动化的国际大公司，旗下产品uipath studio、uipath center、uipath 
      
    
    </summary>
    
    
      <category term="前沿资讯" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E5%89%8D%E6%B2%BF%E8%B5%84%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/9753a2e/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/9753a2e/</id>
    <published>2019-06-26T04:32:24.000Z</published>
    <updated>2019-07-01T07:55:56.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合框架图"><a href="#Java集合框架图" class="headerlink" title="Java集合框架图"></a><strong>Java集合框架图</strong></h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/06/26/Zelvfx.gif" alt title>                </div>                <div class="image-caption"></div>            </figure>  <h1 id="集合框架体系图"><a href="#集合框架体系图" class="headerlink" title="集合框架体系图"></a><strong>集合框架体系图</strong></h1><p><img src="https://s2.ax1x.com/2019/06/26/Ze19XD.png" alt></p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>ArrayList是一个Java容器类动态数组结构,看一下ArrayList的主要继承关系</p><pre><code>public class ArrayList<E> extends AbstractList<E>         implements List<E>, RandomAccess, Cloneable, java.io.Serializable</E></E></E></code></pre><p>通过源码得知这些接口： </p><ul><li>List接口表明ArrayList是List的一种表现形式</li><li>RandomAccess接口表明ArrayList支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能</li><li>Cloneable接口表明必须实现clone()方法，clone()方法可以直接引用父类的clone()方法</li><li>Serializable接口表面可以使用Java默认的序列化机制，允许javabean序列化<br><img src="https://s2.ax1x.com/2019/06/26/ZeNMRA.png" alt><br>类图  <h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2></li></ul><table><thead><tr><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td>add</td><td>增加</td></tr><tr><td>contains</td><td>判断是否存在</td></tr><tr><td>get</td><td>获取指定位置的对象</td></tr><tr><td>indexOf</td><td>获取对象所处的位置</td></tr><tr><td>remove</td><td>删除</td></tr><tr><td>set</td><td>替换</td></tr><tr><td>size</td><td>获取大小</td></tr><tr><td>toArray</td><td>转换为数组</td></tr><tr><td>addAll</td><td>把另一个容器所有对象都加进来</td></tr><tr><td>clear</td><td>清空</td></tr></tbody></table><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h1><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h1><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h1><h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a><strong>HashTable</strong></h1><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong>HashMap</strong></h1><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java集合框架图&quot;&gt;&lt;a href=&quot;#Java集合框架图&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架图&quot;&gt;&lt;/a&gt;&lt;strong&gt;Java集合框架图&lt;/strong&gt;&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;
      
    
    </summary>
    
    
      <category term="集合框架" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>散列(hash)学习</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/4cba6a27/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/4cba6a27/</id>
    <published>2019-05-01T08:27:20.000Z</published>
    <updated>2019-10-21T06:18:26.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列(hash)"></a><strong>散列(hash)</strong></h1><p>散列或者说哈希，通过学习我知道：<br>是一种将元素通过散列函数H（）转化为整数，使得整数可以尽量唯一地代表这个元素<br>那么可以用key代表元素未转化，使用H(key)代表转化后的整数                                                                                                         </p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ul><li>直接定址法<br>恒等变换或是线性变换，即直接使用key作为数组下标，H（key）= a*key+b；</li><li>平方取中法<br>使用KEY^2的中间若干位来作为hash值，H（key）= key^2的中间几位；</li><li>除留余数法<br>把key除以一个数mod所得到的余数作为hash值，H（key）= key % mod ；</li></ul><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>我们发现有时候函数并不能代表一个值，通过除留余数法我们可能出现两个不同的key同时取余出相同的哈希值H（key），这时候就产生了冲突。  </p><h2 id="解决冲突的方法"><a href="#解决冲突的方法" class="headerlink" title="解决冲突的方法"></a>解决冲突的方法</h2><ul><li>线性探查法（Linear Probing）<br>当出现冲突时，就检查下一个位置哈希值H（key）+1的位置是否被占用，没有就使用；如果仍然被占用就继续往下查找直到表最大，超过表长返回表的首位继续查找，如此循环；不过此方法效率低下，容易出现连续的被占用情况。</li><li>平方探查法（Quadratic Probing）<br>为了避免反复查找位置，可以使用平方顺序进行查找，检查下一个位置H（key）+1^2，H（key）-1^2，H（key）+2^2，H（key）-2^2，H(key)+3^2,H(key+3^2……；当H（key）+k^2大于表长，则使用H（key）+k^2 %表长，H（key）-k^2小于0，则使用（（H(key)-k^2）%表长+表长）%表长，得到一个非负数的哈希值；</li><li>链地址法（拉链法）<br>将所有hash值相同的key连接成一个单链表，其中的List[h]存放H（key）= h的一条单链表，当冲突发生时就遍历链表来寻找所有H（key） = h的key；  </li></ul><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><p>前面的方法都是基于key为整数，那么当想使用一个hash尽可能代表一个字符串就需要其他的方法。<br>可以浅显的理解字符串是数字、字母、特殊字符组成的，那么字符串随机组合分为七种。  </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;散列-hash&quot;&gt;&lt;a href=&quot;#散列-hash&quot; class=&quot;headerlink&quot; title=&quot;散列(hash)&quot;&gt;&lt;/a&gt;&lt;strong&gt;散列(hash)&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;散列或者说哈希，通过学习我知道：&lt;br&gt;是一种将元素通过散列函
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
      <category term="哈希" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>基础的排序算法</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/4c06727b/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/4c06727b/</id>
    <published>2019-04-30T05:12:41.000Z</published>
    <updated>2019-10-21T06:30:36.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a><strong>算法复杂度</strong></h1><ul><li>一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的</li><li>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。</li><li>算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。  </li></ul><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>一个算法中的语句执行次数。记为T(n),n称为问题的规模;<br>若存在某个函数f(n)，当 n –> ∞时，T(n) / f(n) 为不等于0的常数，则称f(n)是T(n)的同数量级函数。记为T(n) = O(f(n))；称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。</li><li>常见的时间复杂度</li></ul><table><thead><tr><th style="text-align:center">常数阶</th><th style="text-align:center">对数阶</th><th style="text-align:center">线性阶</th><th style="text-align:center">线性对数阶</th><th style="text-align:center">平方阶</th><th style="text-align:center">立方阶</th><th style="text-align:center">K次方阶</th><th style="text-align:center">指数阶</th></tr></thead><tbody><tr><td style="text-align:center">O(1)</td><td style="text-align:center">O(log2^n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(nlog2^n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^3)</td><td style="text-align:center">O(n^k)</td><td style="text-align:center">O(2^n)</td></tr></tbody></table><blockquote><p>随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p></blockquote><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。</p><ul><li>存储算法本身所占用的存储空间</li><li>算法的输入输出数据所占用的存储空间</li><li>算法在运行过程中临时占用的存储空间</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h1><p>冒泡排序是最基础的一种排序算法，让序列元素像汽泡一样”浮”上来<br>冒泡排序本质在于交换元素，每次判断两个相邻元素的大小交换位置，直到剩余元素为0时。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>比较相邻的元素。如果第一个比第二个大，则交换</li><li>整个过程进行n个元素-1次<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main(){</span><br><span class="line">//定义一个数组</span><br><span class="line">int a[10] = {2,0,1,9,4,3,0};</span><br><span class="line">//遍历n-1数组</span><br><span class="line">for (int i =0;i<=6;i++){< span><br><span class="line">    //第i次从a[0]~a[n-i]与他们下一个数比较</span><br><span class="line">    for(int j=0;j<6-i;j++){< span><br><span class="line">        //判断相邻大小进行交换</span><br><span class="line">        if(a[j]>a[j+1]){</span><br><span class="line">            //中间变量temp</span><br><span class="line">            int temp = a[j];</span><br><span class="line">            a[j] = a[j+1];</span><br><span class="line">            a[j+1] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//打印输出</span><br><span class="line">for(int i=0;i<7;i++){< span><br><span class="line">    printf("%d",a[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">}</span><br></7;i++){<></span></6-i;j++){<></span></=6;i++){<></span></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>输出结果：0 0 1 2 3 4 9</p></blockquote><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>“正序”排列时，比较次数为n-1，所以最好情况下的时间复杂度为O(n)；  </li><li>“逆序”排序时，比较次数为n(n-1)/2，所以冒泡排序在最坏情况下的时间复杂度为O(n^2)</li></ul><ul><li>过程中需要一个临时变量temp，所需要的额外空间为1，空间复杂度则为O(1)。  </li><li>元素交换时，相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。  </li></ul><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均复杂度</th><th style="text-align:center">空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td>稳定</td></tr></tbody></table><hr><hr><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h1><p>简单选择排序就是选择元素放置<br>选择无序序列中最小（大）的元素放入有序序列中，进行n个元素次数的操作  </p><h2 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>初始有序区和无序区  </li><li>从a[0]开始判断无序序列中最小的元素  </li><li>与a[0]交换，记录为有序序列</li><li>进行n个元素次，直到全部有序  </li></ul><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    //定义一个数组</span><br><span class="line">    int a[10] = {2,0,1,9,4,3,0};</span><br><span class="line">    //进行n次操作</span><br><span class="line">    for(int i = 0;i<=6;i++){< span><br><span class="line">        //k为最小值数组下标</span><br><span class="line">        int k = i;</span><br><span class="line">        //遍历无序序列</span><br><span class="line">        for(int j = i;j<=6;j++){< span><br><span class="line">            //选择最大元素</span><br><span class="line">            if(a[j]<a[k]){< span><br><span class="line">                //交换i和j的下标</span><br><span class="line">                k=j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        //中间变量temp</span><br><span class="line">        int temp = a[i];</span><br><span class="line">        a[i] = a[k];</span><br><span class="line">        a[k] = temp;</span><br><span class="line">    }</span><br><span class="line">    //打印输出</span><br><span class="line">    for(int i=0;i<7;i++){< span><br><span class="line">        printf("%d",a[i]);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></7;i++){<></span></a[k]){<></span></=6;j++){<></span></=6;i++){<></span></pre></td></tr></tbody></table></figure><blockquote><p>输出结果：9 4 3 2 1 0 0  </p></blockquote><h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>简单选择排序表现最稳定的排序算法之一，无论正序倒序无序数据进去都是O(n2)的时间复杂度  </li><li>过程中需要一个临时变量temp，所需要的额外空间为1，空间复杂度则为O(1)。  </li><li>元素交换时，相同元素的前后顺序发生改变，所以冒泡排序是一种不稳定的排序算法。  </li></ul><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均复杂度</th><th style="text-align:center">空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td>不稳定</td></tr></tbody></table><hr><hr><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a><strong>直接插入排序</strong></h1><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入  </p><h2 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>序列第一个元素已经有序  </li><li>取未排序数据为新元素  </li><li>从后向前比较是否比新元素大</li><li>在其后插入新元素  </li><li>反复n-1趟排序  <h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    int a[10] = {2,0,1,9,4,3,0};</span><br><span class="line">    //进行n-1趟排序</span><br><span class="line">    for(int i=1;i<=6;i++){< span><br><span class="line">        //temp存放</span><br><span class="line">        int temp = a[i];</span><br><span class="line">        //j</span><br><span class="line">        int j = i-1;</span><br><span class="line">        //temp小于前一个元素</span><br><span class="line">        while(j>=0&&temp<a[j-1]){< span><br><span class="line">            //把序列后移一位</span><br><span class="line">            a[j] = a[j-1];</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        //插入位置为j</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     //打印输出</span><br><span class="line">    for(int i=0;i<7;i++){< span><br><span class="line">        printf("%d",a[i]);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line">```  </span><br><span class="line">> 输出结果：0 0 1 2 3 4 9</span><br><span class="line">## 性能分析 </span><br><span class="line">- 简单插入排序在最好情况下，需要比较n-1次，无需交换元素，时间复杂度为O(n)。  </span><br><span class="line">- 在最坏情况下，时间复杂度依然为O(n2)。  </span><br><span class="line">- 但是在数组元素随机排列的情况下，插入排序还是要优于上面两种排序的。  </span><br><span class="line">- 过程中需要一个临时变量temp，所需要的额外空间为1，空间复杂度则为O(1)。  </span><br><span class="line">- 元素交换时，相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。  </span><br><span class="line"></span><br><span class="line">| 时间复杂度 | 最好情况 | 最坏情况 | 平均复杂度 | 空间复杂度 | 稳定性 |</span><br><span class="line">| :-: | :-: | :-: | :-: | :-: |</span><br><span class="line">|简单插入排序|O(n)|O(n^2)|O(n^2)|O(1)|稳定|  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># **希尔排序** </span><br><span class="line">shellSort，又称“缩小增量排序”，是1959年D.L.shell提出的。</span><br><span class="line">## 算法步骤 </span><br><span class="line">- 先将整个待排序列分割成若干个子序列分别进行直接插入排序  </span><br><span class="line">- 然后依次缩减增量再进行排序  </span><br><span class="line">- 待整个序列中的元素基本有序时</span><br><span class="line">- 在对全体元素进行一次直接插入排序    </span><br><span class="line"></span><br><span class="line">## 代码示例</span><br></7;i++){<></span></a[j-1]){<></span></=6;i++){<></span></pre></td></tr></tbody></table></figure></li></ul><p>//从第一个子序列的第二条记录开始顺序扫描待排序列<br>void ShellInsert(RecordList L, int dk){<br>    for(i=dk+1;i<=L.length;i++)<br>        //属于哪一子序列<br>        if(L.r[i].key<L.r[i-dk].key){<br>            L.r[0] = L.r[i];<br>            //子序列增量减少<br>            for(j=i-dk;j>0 && (L.r[0].key<L.r[j].key);j-=dk) <br>                L.r[j+dk] = L.r[j];<br>                L.r[j+dk] = L.r[0];<br>        }<br>}<br>//直接插入<br>void ShellSort(RecordList L,int dlta[],int t){<br>    for(k=0;k<L.length;t++)<br>        ShellInsert(L,dlta[k]);<br>}<br><code>`</code></L.length;t++)<br></L.r[j].key);j-=dk)></L.r[i-dk].key){<br></=L.length;i++)<br></p><blockquote><p>输出结果：无</p></blockquote><h2 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>序列越有序，排序越快</li><li>一个好的希尔排序执行时间大程度依赖于增量的选取  </li><li>大多情况下选用“增量每次除以2递减”  ，其时间复杂度为O(n^2)</li><li>新的增量序列（2k-1，2k-1-1,2k-1-1-1，……7,3,1），其复杂度可以到达O(n^3/2)效率更好</li><li>序列中相同的关键字其排序先后位置发生了改变，故希尔排序是不稳定的算法  </li></ul><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均复杂度</th><th style="text-align:center">空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">O(n^3/2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td>不稳定</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>golang编写日志存储及可视化demo</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/a5aa196c/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/a5aa196c/</id>
    <published>2019-03-04T07:20:37.000Z</published>
    <updated>2019-10-30T09:46:36.154Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL基础知识</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/993e51d1/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/993e51d1/</id>
    <published>2018-12-01T07:25:27.000Z</published>
    <updated>2019-10-21T06:33:07.261Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
      <category term="数据库" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/MySQL/"/>
    
      <category term="基础" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/24d91ba1/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/24d91ba1/</id>
    <published>2018-11-04T12:44:59.000Z</published>
    <updated>2018-11-06T13:45:59.551Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客教程</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/6688b830/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/6688b830/</id>
    <published>2018-11-04T06:57:32.000Z</published>
    <updated>2019-10-21T06:20:34.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h1><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><ol><li>下载并安装Node.js 官网： <a href="http://nodejs.org/download/" target="_blank" rel="noopener">http://nodejs.org/download/</a></li><li>安装的时候Custom Setup选择第一个，安装完成。</li></ol><h2 id="Git下载安装及其配置"><a href="#Git下载安装及其配置" class="headerlink" title="Git下载安装及其配置"></a>Git下载安装及其配置</h2><ol><li>下载并安装Git 官网:  <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></li><li>安装Git一路Next即可,Git安装完成.  </li><li>Git简单的教程请看廖雪峰的官方网:<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></li></ol><h2 id="安装并启动Hexo"><a href="#安装并启动Hexo" class="headerlink" title="安装并启动Hexo"></a>安装并启动Hexo</h2><ol><li><p>在自己的本地磁盘中手动新建一个Hexo文件夹来存储本地文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/11/04/5bdef8af8cde0.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>到你新建的Hexo根目录右键选择  Git Bash Here</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/11/04/5bdefe5eeae87.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>在git命令框安装Hexo，输入命令<br><code>npm install -g hexo</code></p></li><li>安装完成后，初始化hexo命令:<br><code>hexo init</code></li><li><p>启动hexo服务<br>命令：npm install –><br>hexo s –>hexo clean –>hexo g –>hexo d  </p></li><li><p>hexo s 命令部署本地服务器<br>浏览器输入<a href="http://localhost:4000可访问到初始页面" target="_blank" rel="noopener">http://localhost:4000可访问到初始页面</a>  </p></li><li><p>如果部署提示找不到git<br>解决办法：<br>在Hexo 3.0版本后deploy git 被分开的，所以需要安装。<br>安装命令如下:<br><code>npm install hexo-deployer-git --save</code><br>安装好后再尝试一下重新部署就ok。</p><blockquote><p><em>如果下载速度缓慢可以配置全局配置设置到淘宝源:</em> 命令如下:<br><code>npm config set registry https://registry.npm.taobao.org</code>  </p></blockquote></li></ol><h1 id="Github相关"><a href="#Github相关" class="headerlink" title="Github相关"></a><strong>Github相关</strong></h1><h2 id="注册github的账号"><a href="#注册github的账号" class="headerlink" title="注册github的账号"></a>注册github的账号</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iT9LuD.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="创建一个新的仓库"><a href="#创建一个新的仓库" class="headerlink" title="创建一个新的仓库"></a>创建一个新的仓库</h2><p><img src="https://s1.ax1x.com/2018/11/06/iT9HgK.png" alt></p><pre><code>仓库名必须遵守相应格式：username.github.io 这样子在访问主页的时候直接用 username.github.io 就能访问.</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iT9bjO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p> 现在需要把你电脑里的clone到github仓库就需要git来帮忙了</p><h2 id="设置Git的姓名和邮箱"><a href="#设置Git的姓名和邮箱" class="headerlink" title="设置Git的姓名和邮箱"></a>设置Git的姓名和邮箱</h2><p>命令： </p><p><code>git config --global user.name "your_name"</code><br><code>git config --global user.email "your_email"</code>  </p><h2 id="添加SSH-key"><a href="#添加SSH-key" class="headerlink" title="添加SSH key"></a>添加SSH key</h2><p>为了每次提交到github不需要重复输入账号密码，所以要设置ssh密钥，github连接仓库是由ssh密钥认证的,所以要添加自己的密钥进去  </p><p>输入以下命令：<br><code>ssh-keygen -t rsa -C "your_email"</code><br>回车输入密码可继续三次回车跳过  </p><p>在/Users/your_user_directory/.ssh/x下生成了私有密钥id_rsa和公开密钥id_rsa.pub<br>》选择公有密钥用记事本打开<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTPxpt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p></p><ul><li>复制公钥内容</li><li>进入github设置中的ssh设置  </li><li>新建一个ssh-key，Title随便取一个，粘贴刚复制的key，保存<br><img src="https://s1.ax1x.com/2018/11/06/iTi3N9.png" alt><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTiY1x.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTiRu8.png" alt title>                </div>                <div class="image-caption"></div>            </figure>最后验证是否添加成功<br>返回到hexo文件夹打开git bash命令行，输入命令：<br><code>ssh -T git@github.com</code><br><img src="https://s1.ax1x.com/2018/11/06/iTi5Nj.png" alt><br>看到这段话说明成功连接到你的github。<h1 id="浏览博客"><a href="#浏览博客" class="headerlink" title="浏览博客"></a><strong>浏览博客</strong></h1></li></ul><ol><li><code>hexo s</code>  <blockquote><p>(hexo sever=hexo s)一般用简写方便使用,打开本地服务器，方便发布前的调试。</p></blockquote></li><li><code>hexo g</code>  <blockquote><p>(hexo generate=hexo g)一般用简写，是生成静态文件的命令。</p></blockquote></li><li><p><code>hexo d</code>  </p><blockquote><p>(hexo deploy=hexo d)也是简写，部署之前预先生成静态文件  </p></blockquote><p>更多指令请看官方文档：<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a>  </p></li><li><p>浏览器中输入<a href="http://githubname.github.io" target="_blank" rel="noopener">http://githubname.github.io</a>  就可以看到hexo博客了!!!。</p><h1 id="域名设置"><a href="#域名设置" class="headerlink" title="域名设置"></a><strong>域名设置</strong></h1></li></ol><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p> 去阿里云或者其他域名网站选择购买域名，这里提供几个域名站的连接：<br> <a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">https://sg.godaddy.com/zh/</a>  #Godady<br> <a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">https://wanwang.aliyun.com/</a> #阿里云<br> <a href="https://dnspod.cloud.tencent.com/" target="_blank" rel="noopener">https://dnspod.cloud.tencent.com/</a> #腾讯云  </p><h2 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h2><p>  通过域名解析将我们的GitHub主页的域名解析到我们自己买的域名上面来，这样我们就可以通过我们自己的域名来访问我们的博客了  </p><ol><li><p>我是使用的阿里云解析，登陆域名控制台,看到你的域名后<br>点击解析 </p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTAauV.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>记录类型为：CNAME<br>记录两个值：@和www<br>记录值： 自己的github仓库地址<br>TTL： 10分钟</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTA4ED.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>接下来需要在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：name.com<br><img src="https://s1.ax1x.com/2018/11/06/iTE1r6.png" alt><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTEJaD.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol><p>最后重新部署你的博客<br>hexo clean # 清理<br>hexo g<br>hexo d<br>通过你自己的域名访问你的博客吧！</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h1><p>Hexo的配置文件设置及themes模板主题修改在下一篇文章当中。<br>感谢你的阅读，文章用于个人学习记录。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;&lt;strong&gt;环境搭建&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;Node-js&quot;&gt;&lt;a href=&quot;#Node-js&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="总结教程" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%80%BB%E7%BB%93%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="搭建" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/4263f441/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/4263f441/</id>
    <published>2018-10-21T05:54:15.000Z</published>
    <updated>2019-10-30T09:42:43.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><em>平衡二叉树</em></h1><p>平衡二叉树（AVL树）是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1，是一种高平衡的二叉排序树  </p><h2 id="平衡因子-BF"><a href="#平衡因子-BF" class="headerlink" title="平衡因子(BF)"></a>平衡因子(BF)</h2><ul><li>将二叉排序树上的节点的左子树深度减去右子树深度的值叫做平衡因子</li><li>平衡二叉树的平衡因子只能为 -1,0,1</li><li>二叉树上若有一个节点的平衡因子的绝对值大于1，则不平衡</li></ul><h2 id="最小不平衡子树"><a href="#最小不平衡子树" class="headerlink" title="最小不平衡子树"></a>最小不平衡子树</h2><ul><li>距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树</li></ul><h3 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h3><h2 id="构建平衡二叉树"><a href="#构建平衡二叉树" class="headerlink" title="构建平衡二叉树"></a>构建平衡二叉树</h2><ol><li>在构建二叉排序树的过程中，每当插入一个节点时，先检查是否因插入而破坏了树的平衡性</li><li>若没有破坏，则仍为平衡二叉树</li><li>若有，则调整最小不平衡子树中各节点之间的链接关系，进行相应的旋转，使之成为新的平衡子树</li></ol><h3 id="构建示例"><a href="#构建示例" class="headerlink" title="构建示例"></a>构建示例</h3><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>结构定义：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode</span><br><span class="line">{</span><br><span class="line">    int data;//节点数据</span><br><span class="line">    int bf;//平衡因子</span><br><span class="line">    struct BiTNode *lchild, *rchild;//左右孩子指针</span><br><span class="line"></span><br><span class="line">}BiTNode , *BiTree;</span><br></pre></td></tr></tbody></table></figure><p></p><p>右旋操作:<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//以p为根的二叉排序树</span><br><span class="line">void Right_Rotate(BiTree *p)</span><br><span class="line">{</span><br><span class="line">    BiTree L;</span><br><span class="line">    L=(*p) ->lchild;</span><br><span class="line">    (*p) ->lchild= L->rchild;</span><br><span class="line">    L->rchild=(*p);</span><br><span class="line">    *p=L;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>左旋操作：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Left_Rotate(BiTree *p)</span><br><span class="line">{</span><br><span class="line">    BiTree R;</span><br><span class="line">    R= (*p) -> rchild;</span><br><span class="line">    (*p)->rchild=R->lchild;</span><br><span class="line">    R -> lchild=(*p);</span><br><span class="line">    *p=R;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>左平衡旋转处理：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#define LH +1 //左高</span><br><span class="line">#define EH 0 //等高</span><br><span class="line">#define RH -1 //右高</span><br><span class="line"></span><br><span class="line">void RightBalance(BiTree *T)</span><br><span class="line">{</span><br><span class="line">    BiTree L,Lr;</span><br><span class="line">    L=(*T)->lchild;</span><br><span class="line">    switch(L->bf)//平衡度处理</span><br><span class="line">    {</span><br><span class="line">        /*新节点插入在T的左孩子的左子树上*/</span><br><span class="line">        case LH:</span><br><span class="line">            (*T) ->bf=L->bf=EH;</span><br><span class="line">            Right_Rotate(T);</span><br><span class="line">            break;</span><br><span class="line">        /*新节点插入在T的左孩子的右子树上*/</span><br><span class="line">        case RH:</span><br><span class="line">            Lr=L->rchild;</span><br><span class="line">            /*修改T及其左孩子的平衡因子*/</span><br><span class="line">            switch(Lr->bf)</span><br><span class="line">            {</span><br><span class="line">                case LH:</span><br><span class="line">                    (*T)->bf=RH;</span><br><span class="line">                    L->bf=EH;</span><br><span class="line">                    break;</span><br><span class="line">                case EH:</span><br><span class="line">                    (*T)->bf=L->bf=EH;</span><br><span class="line">                    break;</span><br><span class="line">                case RH:</span><br><span class="line">                    (*T)->bf=EH</span><br><span class="line">                    L->bf=LH;</span><br><span class="line">                    break;</span><br><span class="line">            }</span><br><span class="line">        Lr->bf=EH;</span><br><span class="line">        Left_Rotate(&(*T)->lchild);</span><br><span class="line">        Right_Rotate(T);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>右平衡旋转处理：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#define LH +1 //左高</span><br><span class="line">#define EH 0 //等高</span><br><span class="line">#define RH -1 //右高</span><br><span class="line"></span><br><span class="line">void LeftBalance(BiTree *T)</span><br><span class="line">{</span><br><span class="line">    BiTree R,Rl;</span><br><span class="line">    R=(*T)->rchild;</span><br><span class="line">    switch(R->bf)//平衡度处理</span><br><span class="line">    {</span><br><span class="line">        /*新节点插入在T的右孩子的右子树上*/</span><br><span class="line">        case RH:</span><br><span class="line">            (*T) ->bf=R->bf=EH;</span><br><span class="line">            Left_Rotate(T);</span><br><span class="line">            break;</span><br><span class="line">        /*新节点插入在T的右孩子的左子树上*/</span><br><span class="line">        case LH:</span><br><span class="line">            Rl=R->lchild;</span><br><span class="line">            /*修改T及其右孩子的平衡因子*/</span><br><span class="line">            switch(Rl->bf)</span><br><span class="line">            {</span><br><span class="line">                case RH:</span><br><span class="line">                    (*T)->bf=LH;</span><br><span class="line">                    R->bf=EH;</span><br><span class="line">                    break;</span><br><span class="line">                case EH:</span><br><span class="line">                    (*T)->bf=R->bf=EH;</span><br><span class="line">                    break;</span><br><span class="line">                case LH:</span><br><span class="line">                    (*T)->bf=EH</span><br><span class="line">                    R->bf=RH;</span><br><span class="line">                    break;</span><br><span class="line">            }</span><br><span class="line">        Rl->bf=EH;</span><br><span class="line">        Right_Rotate(&(*T)->rchild);</span><br><span class="line">        Left_Rotate(T);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>主函数<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/*int类型e表示新节点，布尔类型*taller表示T的深度*/</span><br><span class="line">Status InsertAVL(BiTree *T,int e,Status *taller)</span><br><span class="line">{</span><br><span class="line">    if(!*T)</span><br><span class="line">    {</span><br><span class="line">        /*插入新节点，树"长高",置taller为TRUE*/</span><br><span class="line">        *T=(BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        (*T)->data=e;</span><br><span class="line">        (*T)->lchild-(*T)->rchild=NULL;</span><br><span class="line">        (*T)->bf=EH;</span><br><span class="line">        *taller=TRUE;</span><br><span class="line">    }</span><br><span class="line">    else</span><br><span class="line">    {</span><br><span class="line">        if (e==(*T)->data)</span><br><span class="line">        {</span><br><span class="line">            /*树中已存在和e有相同关键字的节点则不再插入*/</span><br><span class="line">            *taller=FALSE;</span><br><span class="line">            return FALSE;</span><br><span class="line">        }</span><br><span class="line">        if (e<(*T)->data)</span><br><span class="line">        {</span><br><span class="line">            /*继续在T的左子树中进行搜索*/</span><br><span class="line">            if(!InsertAVL(&(*T)->lchild,e,taller))</span><br><span class="line">                return FALSE; //未插入</span><br><span class="line">            //已插入到T的左子树且左子树深度增加</span><br><span class="line">            if(*taller)</span><br><span class="line">            {</span><br><span class="line">                switch((*T)->bf)//检查T的平衡度</span><br><span class="line">                {</span><br><span class="line">                    case LH:</span><br><span class="line">                        LeftBalance(T);</span><br><span class="line">                        *taller=FALSE;</span><br><span class="line">                        break;</span><br><span class="line">                    case EH:</span><br><span class="line">                        (*T)->bf=LH;</span><br><span class="line">                        *taller=TRUE;</span><br><span class="line">                        break;</span><br><span class="line">                    case RH:</span><br><span class="line">                        (*T)->bf=EH;</span><br><span class="line">                        *taller=FALSE;</span><br><span class="line">                        break;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        else</span><br><span class="line">        {</span><br><span class="line">            /*继续在T的右子树中进行搜索*/</span><br><span class="line">            if(!InsertAVL(&(*T)->rchild,e,taller))</span><br><span class="line">                return FALSE;//未插入</span><br><span class="line">            /*已插入到T的右子树且深度增加*/</span><br><span class="line">            if(*taller)</span><br><span class="line">            {</span><br><span class="line">                </span><br><span class="line">                switch((*T)->bf)//检查平衡度</span><br><span class="line">                {</span><br><span class="line">                    case LH:</span><br><span class="line">                        (*T)->bf=EH;</span><br><span class="line">                        *taller=FALSE;</span><br><span class="line">                        break;</span><br><span class="line">                    case EH:</span><br><span class="line">                        (*T)->bf=RH;</span><br><span class="line">                        *taller=TRUE;</span><br><span class="line">                        break;</span><br><span class="line">                    case RH:</span><br><span class="line">                        RightBanlance(T);</span><br><span class="line">                        *taller=FALSE;</span><br><span class="line">                        break;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>构建平衡二叉树:<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">int a[10]={3,2,1,4,5,6,7,10,9,8}</span><br><span class="line">BiTree T=NUll;</span><br><span class="line">Status taller;</span><br><span class="line">for (i=0;i<10;i++)</span><br><span class="line">{</span><br><span class="line">    InsertAVL (&T,a[i],&taller);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><ul><li>此算法为动态查找表算法，即在构造二叉排序树过程中进行旋转达到平衡为动态的进行查找</li><li>一旦发生不平衡马上处理旋转</li><li>旋转过后变为平衡二叉树，即较为平衡，用二叉排序查找时间复杂度为O（logn）插入删除也为O（logn）<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;&lt;em&gt;平衡二叉树&lt;/em&gt;&lt;/h1&gt;&lt;p&gt;平衡二叉树（AVL树）是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1，是一种高
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
      <category term="树" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>golang编写短连接生成器</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/undefined/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/undefined/</id>
    <published>2018-10-20T14:10:59.000Z</published>
    <updated>2019-10-30T09:45:54.616Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang编写单机爬虫（一）</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/63cff225/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/63cff225/</id>
    <published>2018-08-29T05:21:09.000Z</published>
    <updated>2019-10-30T09:45:07.874Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Channel（一）</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/49f8918a/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/49f8918a/</id>
    <published>2018-08-17T13:19:22.000Z</published>
    <updated>2019-10-30T09:44:40.768Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
</feed>
