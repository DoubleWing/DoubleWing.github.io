<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DoubleWing&#39;Blog</title>
  <icon>https://www.gravatar.com/avatar/f69ff1ffbe594409dfb6e458b56c16a0</icon>
  <subtitle>喜欢就坚持吧！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DoubleWing/DoubleWing.github.io/"/>
  <updated>2019-10-21T05:55:33.373Z</updated>
  <id>https://github.com/DoubleWing/DoubleWing.github.io/</id>
  
  <author>
    <name>张昭</name>
    <email>1318911702@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红黑树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/undefined/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/undefined/</id>
    <published>2019-10-21T05:55:33.000Z</published>
    <updated>2019-10-21T05:55:33.373Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>B+树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/17426722/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/17426722/</id>
    <published>2019-10-21T05:55:06.000Z</published>
    <updated>2019-10-21T05:58:50.055Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>B树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/9439fc83/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/9439fc83/</id>
    <published>2019-10-21T05:54:44.000Z</published>
    <updated>2019-10-21T06:02:57.532Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
      <category term="查找" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/4263f441/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/4263f441/</id>
    <published>2019-10-21T05:54:15.000Z</published>
    <updated>2019-10-21T05:58:50.061Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/e5052ecb/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/e5052ecb/</id>
    <published>2019-10-21T05:53:41.000Z</published>
    <updated>2019-10-21T05:58:50.063Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>折半查找</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/8dbf9480/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/8dbf9480/</id>
    <published>2019-10-21T05:52:53.000Z</published>
    <updated>2019-10-21T05:58:50.065Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>顺序查找</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/cc0ea54c/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/cc0ea54c/</id>
    <published>2019-10-21T05:52:07.000Z</published>
    <updated>2019-10-21T05:58:50.067Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>较复杂的排序算法</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/d20d6597/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/d20d6597/</id>
    <published>2019-10-21T04:25:27.000Z</published>
    <updated>2019-10-21T04:33:24.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交换类排序-快速排序"><a href="#交换类排序-快速排序" class="headerlink" title="交换类排序-快速排序"></a>交换类排序-快速排序</h1><h1 id="选择类排序-堆排序"><a href="#选择类排序-堆排序" class="headerlink" title="选择类排序-堆排序"></a>选择类排序-堆排序</h1><h1 id="归并类排序-二路归并排序"><a href="#归并类排序-二路归并排序" class="headerlink" title="归并类排序-二路归并排序"></a>归并类排序-二路归并排序</h1><h1 id="分配类排序-链式基数排序"><a href="#分配类排序-链式基数排序" class="headerlink" title="分配类排序-链式基数排序"></a>分配类排序-链式基数排序</h1><h1 id="外部排序-置换选择排序"><a href="#外部排序-置换选择排序" class="headerlink" title="外部排序-置换选择排序"></a>外部排序-置换选择排序</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;交换类排序-快速排序&quot;&gt;&lt;a href=&quot;#交换类排序-快速排序&quot; class=&quot;headerlink&quot; title=&quot;交换类排序-快速排序&quot;&gt;&lt;/a&gt;交换类排序-快速排序&lt;/h1&gt;&lt;h1 id=&quot;选择类排序-堆排序&quot;&gt;&lt;a href=&quot;#选择类排序-堆排序&quot; c
      
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是uipath</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/ed117eeb/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/ed117eeb/</id>
    <published>2019-10-21T03:12:26.000Z</published>
    <updated>2019-10-21T04:17:01.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UiPath"><a href="#UiPath" class="headerlink" title="UiPath"></a>UiPath</h1><p>一家机器人自动化的国际大公司，旗下产品uipath studio、uipath center、uipath robot都是关于RPA流程开发的工具</p><h2 id="了解途径"><a href="#了解途径" class="headerlink" title="了解途径"></a>了解途径</h2><p>前几日，在36氪上看到前沿信息机器人自动化等等，觉得高大上，感觉是Al的落实项目，<br>随机开始搜索信息关注此行业，从官网到QQ群到微信群再到论坛，无疑此为新型的行业，但是运用的是无编程技术主要是对于业务的了解情况以及思维逻辑和流程图设计，应该划分为业务部分。</p><h1 id="uipath-架构"><a href="#uipath-架构" class="headerlink" title="uipath 架构"></a>uipath 架构</h1><p>打开uipath官网  ，了解其架构体系为：</p><ul><li><p>Studio（编辑器）—— 如各个编译平台一样，uipathStudio 是RPA流程开发工具</p></li><li><p>Ochestrator（中控/web平台）—— 管理所有的流程机器人、以及报表显示，及其他远程控制操作 类似阿里云平台</p></li><li><p>RoBots（机器人（脚本））——机器人安装到不同的电脑中，直接运行开发好的RPA流程，<br>（有两种触发方式<br>1.人机互动，手动才能触发<br>2.VM虚拟机中固定时间自动触发）</p></li></ul><h1 id="应用于"><a href="#应用于" class="headerlink" title="应用于"></a>应用于</h1><ul><li>金融行业（繁杂的业务逻辑，使用简单的机器人代替人工是不错的方案）</li><li>系统陈旧的企业（通过机器人完成业务逻辑，节约再开发再更新的成本）</li></ul><h1 id="国外RPA厂商"><a href="#国外RPA厂商" class="headerlink" title="国外RPA厂商"></a>国外RPA厂商</h1><p>uipath、buleprime、AA（简写）、NICE等</p><h2 id="国内厂商"><a href="#国内厂商" class="headerlink" title="国内厂商"></a>国内厂商</h2><p>艺赛旗、UiBot、达观数据等</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过三天的学习和探索，考取了uibot的认证工程师（其实是20分钟，不需要编程能力（笑），我认为这个行业对于计算机专业的专业编程人员来说不是一种系统学习知识的过程，其中是Excel、VBA、Python、Java、数据库、网络的零星知识点大集合，其中大量的业务逻辑用在UI自动化上，所以根据自己的学习路线应该了解uipath前沿信息，其技能很有可能人人都会用提前了解一下，要去真正的学习有门槛有难度的技术类似于AL、人工智能（我并不认为我能学会（哭）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UiPath&quot;&gt;&lt;a href=&quot;#UiPath&quot; class=&quot;headerlink&quot; title=&quot;UiPath&quot;&gt;&lt;/a&gt;UiPath&lt;/h1&gt;&lt;p&gt;一家机器人自动化的国际大公司，旗下产品uipath studio、uipath center、uipath 
      
    
    </summary>
    
    
      <category term="前沿资讯" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E5%89%8D%E6%B2%BF%E8%B5%84%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/9753a2e/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/9753a2e/</id>
    <published>2019-06-26T04:32:24.000Z</published>
    <updated>2019-07-01T07:55:56.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合框架图"><a href="#Java集合框架图" class="headerlink" title="Java集合框架图"></a><strong>Java集合框架图</strong></h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/06/26/Zelvfx.gif" alt title>                </div>                <div class="image-caption"></div>            </figure>  <h1 id="集合框架体系图"><a href="#集合框架体系图" class="headerlink" title="集合框架体系图"></a><strong>集合框架体系图</strong></h1><p><img src="https://s2.ax1x.com/2019/06/26/Ze19XD.png" alt></p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>ArrayList是一个Java容器类动态数组结构,看一下ArrayList的主要继承关系</p><pre><code>public class ArrayList<E> extends AbstractList<E>         implements List<E>, RandomAccess, Cloneable, java.io.Serializable</code></pre><p>通过源码得知这些接口： </p><ul><li>List接口表明ArrayList是List的一种表现形式</li><li>RandomAccess接口表明ArrayList支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能</li><li>Cloneable接口表明必须实现clone()方法，clone()方法可以直接引用父类的clone()方法</li><li>Serializable接口表面可以使用Java默认的序列化机制，允许javabean序列化<br><img src="https://s2.ax1x.com/2019/06/26/ZeNMRA.png" alt><br>类图  <h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2></li></ul><table><thead><tr><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td>add</td><td>增加</td></tr><tr><td>contains</td><td>判断是否存在</td></tr><tr><td>get</td><td>获取指定位置的对象</td></tr><tr><td>indexOf</td><td>获取对象所处的位置</td></tr><tr><td>remove</td><td>删除</td></tr><tr><td>set</td><td>替换</td></tr><tr><td>size</td><td>获取大小</td></tr><tr><td>toArray</td><td>转换为数组</td></tr><tr><td>addAll</td><td>把另一个容器所有对象都加进来</td></tr><tr><td>clear</td><td>清空</td></tr></tbody></table><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h1><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h1><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h1><h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a><strong>HashTable</strong></h1><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong>HashMap</strong></h1><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java集合框架图&quot;&gt;&lt;a href=&quot;#Java集合框架图&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架图&quot;&gt;&lt;/a&gt;&lt;strong&gt;Java集合框架图&lt;/strong&gt;&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;
      
    
    </summary>
    
    
      <category term="集合框架" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>散列(hash)学习</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/4cba6a27/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/4cba6a27/</id>
    <published>2019-05-01T08:27:20.000Z</published>
    <updated>2019-06-24T06:10:56.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列(hash)"></a><strong>散列(hash)</strong></h1><p>散列或者说哈希，通过学习我知道：<br>是一种将元素通过散列函数H（）转化为整数，使得整数可以尽量唯一地代表这个元素<br>那么可以用key代表元素未转化，使用H(key)代表转化后的整数                                                                                                         </p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ul><li>直接定址法<br>恒等变换或是线性变换，即直接使用key作为数组下标，H（key）= a*key+b；</li><li>平方取中法<br>使用KEY^2的中间若干位来作为hash值，H（key）= key^2的中间几位；</li><li>除留余数法<br>把key除以一个数mod所得到的余数作为hash值，H（key）= key % mod ；</li></ul><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>我们发现有时候函数并不能代表一个值，通过除留余数法我们可能出现两个不同的key同时取余出相同的哈希值H（key），这时候就产生了冲突。  </p><h2 id="解决冲突的方法"><a href="#解决冲突的方法" class="headerlink" title="解决冲突的方法"></a>解决冲突的方法</h2><ul><li>线性探查法（Linear Probing）<br>当出现冲突时，就检查下一个位置哈希值H（key）+1的位置是否被占用，没有就使用；如果仍然被占用就继续往下查找直到表最大，超过表长返回表的首位继续查找，如此循环；不过此方法效率低下，容易出现连续的被占用情况。</li><li>平方探查法（Quadratic Probing）<br>为了避免反复查找位置，可以使用平方顺序进行查找，检查下一个位置H（key）+1^2，H（key）-1^2，H（key）+2^2，H（key）-2^2，H(key)+3^2,H(key+3^2……；当H（key）+k^2大于表长，则使用H（key）+k^2 %表长，H（key）-k^2小于0，则使用（（H(key)-k^2）%表长+表长）%表长，得到一个非负数的哈希值；</li><li>链地址法（拉链法）<br>将所有hash值相同的key连接成一个单链表，其中的List[h]存放H（key）= h的一条单链表，当冲突发生时就遍历链表来寻找所有H（key） = h的key；  </li></ul><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><p>前面的方法都是基于key为整数，那么当想使用一个hash尽可能代表一个字符串就需要其他的方法。<br>可以浅显的理解字符串是数字、字母、特殊字符组成的，那么字符串随机组合分为七种。  </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;散列-hash&quot;&gt;&lt;a href=&quot;#散列-hash&quot; class=&quot;headerlink&quot; title=&quot;散列(hash)&quot;&gt;&lt;/a&gt;&lt;strong&gt;散列(hash)&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;散列或者说哈希，通过学习我知道：&lt;br&gt;是一种将元素通过散列函
      
    
    </summary>
    
    
      <category term="哈希" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>基础的排序算法</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/4c06727b/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/4c06727b/</id>
    <published>2019-04-30T05:12:41.000Z</published>
    <updated>2019-10-21T04:15:28.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a><strong>算法复杂度</strong></h1><ul><li>一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的</li><li>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。</li><li>算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。  </li></ul><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>一个算法中的语句执行次数。记为T(n),n称为问题的规模;<br>若存在某个函数f(n)，当 n –> ∞时，T(n) / f(n) 为不等于0的常数，则称f(n)是T(n)的同数量级函数。记为T(n) = O(f(n))；称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。</li><li>常见的时间复杂度</li></ul><table><thead><tr><th style="text-align:center">常数阶</th><th style="text-align:center">对数阶</th><th style="text-align:center">线性阶</th><th style="text-align:center">线性对数阶</th><th style="text-align:center">平方阶</th><th style="text-align:center">立方阶</th><th style="text-align:center">K次方阶</th><th style="text-align:center">指数阶</th></tr></thead><tbody><tr><td style="text-align:center">O(1)</td><td style="text-align:center">O(log2^n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(nlog2^n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^3)</td><td style="text-align:center">O(n^k)</td><td style="text-align:center">O(2^n)</td></tr></tbody></table><blockquote><p>随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p></blockquote><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。</p><ul><li>存储算法本身所占用的存储空间</li><li>算法的输入输出数据所占用的存储空间</li><li>算法在运行过程中临时占用的存储空间</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h1><p>冒泡排序是最基础的一种排序算法，让序列元素像汽泡一样”浮”上来<br>冒泡排序本质在于交换元素，每次判断两个相邻元素的大小交换位置，直到剩余元素为0时。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>比较相邻的元素。如果第一个比第二个大，则交换</li><li>整个过程进行n个元素-1次<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main(){</span><br><span class="line">//定义一个数组</span><br><span class="line">int a[10] = {2,0,1,9,4,3,0};</span><br><span class="line">//遍历n-1数组</span><br><span class="line">for (int i =0;i<=6;i++){</span><br><span class="line">    //第i次从a[0]~a[n-i]与他们下一个数比较</span><br><span class="line">    for(int j=0;j<6-i;j++){</span><br><span class="line">        //判断相邻大小进行交换</span><br><span class="line">        if(a[j]>a[j+1]){</span><br><span class="line">            //中间变量temp</span><br><span class="line">            int temp = a[j];</span><br><span class="line">            a[j] = a[j+1];</span><br><span class="line">            a[j+1] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//打印输出</span><br><span class="line">for(int i=0;i<7;i++){</span><br><span class="line">    printf("%d",a[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p>输出结果：0 0 1 2 3 4 9</p></blockquote><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>“正序”排列时，比较次数为n-1，所以最好情况下的时间复杂度为O(n)；  </li><li>“逆序”排序时，比较次数为n(n-1)/2，所以冒泡排序在最坏情况下的时间复杂度为O(n^2)</li></ul><ul><li>过程中需要一个临时变量temp，所需要的额外空间为1，空间复杂度则为O(1)。  </li><li>元素交换时，相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。  </li></ul><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均复杂度</th><th style="text-align:center">空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td>稳定</td></tr></tbody></table><hr><hr><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h1><p>简单选择排序就是选择元素放置<br>选择无序序列中最小（大）的元素放入有序序列中，进行n个元素次数的操作  </p><h2 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>初始有序区和无序区  </li><li>从a[0]开始判断无序序列中最小的元素  </li><li>与a[0]交换，记录为有序序列</li><li>进行n个元素次，直到全部有序  </li></ul><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    //定义一个数组</span><br><span class="line">    int a[10] = {2,0,1,9,4,3,0};</span><br><span class="line">    //进行n次操作</span><br><span class="line">    for(int i = 0;i<=6;i++){</span><br><span class="line">        //k为最小值数组下标</span><br><span class="line">        int k = i;</span><br><span class="line">        //遍历无序序列</span><br><span class="line">        for(int j = i;j<=6;j++){</span><br><span class="line">            //选择最大元素</span><br><span class="line">            if(a[j]<a[k]){</span><br><span class="line">                //交换i和j的下标</span><br><span class="line">                k=j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        //中间变量temp</span><br><span class="line">        int temp = a[i];</span><br><span class="line">        a[i] = a[k];</span><br><span class="line">        a[k] = temp;</span><br><span class="line">    }</span><br><span class="line">    //打印输出</span><br><span class="line">    for(int i=0;i<7;i++){</span><br><span class="line">        printf("%d",a[i]);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输出结果：9 4 3 2 1 0 0  </p></blockquote><h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>简单选择排序表现最稳定的排序算法之一，无论正序倒序无序数据进去都是O(n2)的时间复杂度  </li><li>过程中需要一个临时变量temp，所需要的额外空间为1，空间复杂度则为O(1)。  </li><li>元素交换时，相同元素的前后顺序发生改变，所以冒泡排序是一种不稳定的排序算法。  </li></ul><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均复杂度</th><th style="text-align:center">空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td>不稳定</td></tr></tbody></table><hr><hr><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a><strong>直接插入排序</strong></h1><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入  </p><h2 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>序列第一个元素已经有序  </li><li>取未排序数据为新元素  </li><li>从后向前比较是否比新元素大</li><li>在其后插入新元素  </li><li>反复n-1趟排序  <h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int main(){</span><br><span class="line">    int a[10] = {2,0,1,9,4,3,0};</span><br><span class="line">    //进行n-1趟排序</span><br><span class="line">    for(int i=1;i<=6;i++){</span><br><span class="line">        //temp存放</span><br><span class="line">        int temp = a[i];</span><br><span class="line">        //j</span><br><span class="line">        int j = i-1;</span><br><span class="line">        //temp小于前一个元素</span><br><span class="line">        while(j>=0&&temp<a[j-1]){</span><br><span class="line">            //把序列后移一位</span><br><span class="line">            a[j] = a[j-1];</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        //插入位置为j</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     //打印输出</span><br><span class="line">    for(int i=0;i<7;i++){</span><br><span class="line">        printf("%d",a[i]);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line">```  </span><br><span class="line">> 输出结果：0 0 1 2 3 4 9</span><br><span class="line">## 性能分析 </span><br><span class="line">- 简单插入排序在最好情况下，需要比较n-1次，无需交换元素，时间复杂度为O(n)。  </span><br><span class="line">- 在最坏情况下，时间复杂度依然为O(n2)。  </span><br><span class="line">- 但是在数组元素随机排列的情况下，插入排序还是要优于上面两种排序的。  </span><br><span class="line">- 过程中需要一个临时变量temp，所需要的额外空间为1，空间复杂度则为O(1)。  </span><br><span class="line">- 元素交换时，相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。  </span><br><span class="line"></span><br><span class="line">| 时间复杂度 | 最好情况 | 最坏情况 | 平均复杂度 | 空间复杂度 | 稳定性 |</span><br><span class="line">| :-: | :-: | :-: | :-: | :-: |</span><br><span class="line">|简单插入排序|O(n)|O(n^2)|O(n^2)|O(1)|稳定|  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># **希尔排序** </span><br><span class="line">shellSort，又称“缩小增量排序”，是1959年D.L.shell提出的。</span><br><span class="line">## 算法步骤 </span><br><span class="line">- 先将整个待排序列分割成若干个子序列分别进行直接插入排序  </span><br><span class="line">- 然后依次缩减增量再进行排序  </span><br><span class="line">- 待整个序列中的元素基本有序时</span><br><span class="line">- 在对全体元素进行一次直接插入排序    </span><br><span class="line"></span><br><span class="line">## 代码示例</span><br></pre></td></tr></tbody></table></figure></li></ul><p>//从第一个子序列的第二条记录开始顺序扫描待排序列<br>void ShellInsert(RecordList L, int dk){<br>    for(i=dk+1;i<=L.length;i++)<br>        //属于哪一子序列<br>        if(L.r[i].key<L.r[i-dk].key){<br>            L.r[0] = L.r[i];<br>            //子序列增量减少<br>            for(j=i-dk;j>0 && (L.r[0].key<L.r[j].key);j-=dk)//<br>                L.r[j+dk] = L.r[j];<br>                L.r[j+dk] = L.r[0];<br>        }<br>}<br>//直接插入<br>void ShellSort(RecordList L,int dlta[],int t){<br>    for(k=0;k<L.length;t++)<br>        ShellInsert(L,dlta[k]);<br>}<br><code>`</code></p><blockquote><p>输出结果：无</p></blockquote><h2 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>序列越有序，排序越快</li><li>一个好的希尔排序执行时间大程度依赖于增量的选取  </li><li>大多情况下选用“增量每次除以2递减”  ，其时间复杂度为O(n^2)</li><li>新的增量序列（2k-1，2k-1-1,2k-1-1-1，……7,3,1），其复杂度可以到达O(n^3/2)效率更好</li><li>序列中相同的关键字其排序先后位置发生了改变，故希尔排序是不稳定的算法  </li></ul><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均复杂度</th><th style="text-align:center">空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">O(n^3/2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td>不稳定</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的
      
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/DoubleWing/DoubleWing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>理解学习MySQL</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/993e51d1/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/993e51d1/</id>
    <published>2018-12-01T07:25:27.000Z</published>
    <updated>2019-04-30T05:00:27.096Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/24d91ba1/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/24d91ba1/</id>
    <published>2018-11-04T12:44:59.000Z</published>
    <updated>2018-11-06T13:45:59.551Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客教程</title>
    <link href="https://github.com/DoubleWing/DoubleWing.github.io//posts/6688b830/"/>
    <id>https://github.com/DoubleWing/DoubleWing.github.io//posts/6688b830/</id>
    <published>2018-11-04T06:57:32.000Z</published>
    <updated>2019-04-30T06:48:13.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h1><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><ol><li>下载并安装Node.js 官网： <a href="http://nodejs.org/download/" target="_blank" rel="noopener">http://nodejs.org/download/</a></li><li>安装的时候Custom Setup选择第一个，安装完成。</li></ol><h2 id="Git下载安装及其配置"><a href="#Git下载安装及其配置" class="headerlink" title="Git下载安装及其配置"></a>Git下载安装及其配置</h2><ol><li>下载并安装Git 官网:  <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></li><li>安装Git一路Next即可,Git安装完成.  </li><li>Git简单的教程请看廖雪峰的官方网:<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></li></ol><h2 id="安装并启动Hexo"><a href="#安装并启动Hexo" class="headerlink" title="安装并启动Hexo"></a>安装并启动Hexo</h2><ol><li><p>在自己的本地磁盘中手动新建一个Hexo文件夹来存储本地文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/11/04/5bdef8af8cde0.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>到你新建的Hexo根目录右键选择  Git Bash Here</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/11/04/5bdefe5eeae87.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>在git命令框安装Hexo，输入命令<br><code>npm install -g hexo</code></p></li><li>安装完成后，初始化hexo命令:<br><code>hexo init</code></li><li><p>启动hexo服务<br>命令：npm install –><br>hexo s –>hexo clean –>hexo g –>hexo d  </p></li><li><p>hexo s 命令部署本地服务器<br>浏览器输入<a href="http://localhost:4000可访问到初始页面" target="_blank" rel="noopener">http://localhost:4000可访问到初始页面</a>  </p></li><li><p>如果部署提示找不到git<br>解决办法：<br>在Hexo 3.0版本后deploy git 被分开的，所以需要安装。<br>安装命令如下:<br><code>npm install hexo-deployer-git --save</code><br>安装好后再尝试一下重新部署就ok。</p><blockquote><p><em>如果下载速度缓慢可以配置全局配置设置到淘宝源:</em> 命令如下:<br><code>npm config set registry https://registry.npm.taobao.org</code>  </p></blockquote></li></ol><h1 id="Github相关"><a href="#Github相关" class="headerlink" title="Github相关"></a><strong>Github相关</strong></h1><h2 id="注册github的账号"><a href="#注册github的账号" class="headerlink" title="注册github的账号"></a>注册github的账号</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iT9LuD.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="创建一个新的仓库"><a href="#创建一个新的仓库" class="headerlink" title="创建一个新的仓库"></a>创建一个新的仓库</h2><p><img src="https://s1.ax1x.com/2018/11/06/iT9HgK.png" alt></p><pre><code>仓库名必须遵守相应格式：username.github.io 这样子在访问主页的时候直接用 username.github.io 就能访问.</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iT9bjO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p> 现在需要把你电脑里的clone到github仓库就需要git来帮忙了</p><h2 id="设置Git的姓名和邮箱"><a href="#设置Git的姓名和邮箱" class="headerlink" title="设置Git的姓名和邮箱"></a>设置Git的姓名和邮箱</h2><p>命令： </p><p><code>git config --global user.name "your_name"</code><br><code>git config --global user.email "your_email"</code>  </p><h2 id="添加SSH-key"><a href="#添加SSH-key" class="headerlink" title="添加SSH key"></a>添加SSH key</h2><p>为了每次提交到github不需要重复输入账号密码，所以要设置ssh密钥，github连接仓库是由ssh密钥认证的,所以要添加自己的密钥进去  </p><p>输入以下命令：<br><code>ssh-keygen -t rsa -C "your_email"</code><br>回车输入密码可继续三次回车跳过  </p><p>在/Users/your_user_directory/.ssh/x下生成了私有密钥id_rsa和公开密钥id_rsa.pub<br>》选择公有密钥用记事本打开<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTPxpt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p></p><ul><li>复制公钥内容</li><li>进入github设置中的ssh设置  </li><li>新建一个ssh-key，Title随便取一个，粘贴刚复制的key，保存<br><img src="https://s1.ax1x.com/2018/11/06/iTi3N9.png" alt><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTiY1x.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTiRu8.png" alt title>                </div>                <div class="image-caption"></div>            </figure>最后验证是否添加成功<br>返回到hexo文件夹打开git bash命令行，输入命令：<br><code>ssh -T git@github.com</code><br><img src="https://s1.ax1x.com/2018/11/06/iTi5Nj.png" alt><br>看到这段话说明成功连接到你的github。<h1 id="浏览博客"><a href="#浏览博客" class="headerlink" title="浏览博客"></a><strong>浏览博客</strong></h1></li></ul><ol><li><code>hexo s</code>  <blockquote><p>(hexo sever=hexo s)一般用简写方便使用,打开本地服务器，方便发布前的调试。</p></blockquote></li><li><code>hexo g</code>  <blockquote><p>(hexo generate=hexo g)一般用简写，是生成静态文件的命令。</p></blockquote></li><li><p><code>hexo d</code>  </p><blockquote><p>(hexo deploy=hexo d)也是简写，部署之前预先生成静态文件  </p></blockquote><p>更多指令请看官方文档：<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a>  </p></li><li><p>浏览器中输入<a href="http://githubname.github.io" target="_blank" rel="noopener">http://githubname.github.io</a>  就可以看到hexo博客了!!!。</p><h1 id="域名设置"><a href="#域名设置" class="headerlink" title="域名设置"></a><strong>域名设置</strong></h1></li></ol><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p> 去阿里云或者其他域名网站选择购买域名，这里提供几个域名站的连接：<br> <a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">https://sg.godaddy.com/zh/</a>  #Godady<br> <a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">https://wanwang.aliyun.com/</a> #阿里云<br> <a href="https://dnspod.cloud.tencent.com/" target="_blank" rel="noopener">https://dnspod.cloud.tencent.com/</a> #腾讯云  </p><h2 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h2><p>  通过域名解析将我们的GitHub主页的域名解析到我们自己买的域名上面来，这样我们就可以通过我们自己的域名来访问我们的博客了  </p><ol><li><p>我是使用的阿里云解析，登陆域名控制台,看到你的域名后<br>点击解析 </p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTAauV.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>记录类型为：CNAME<br>记录两个值：@和www<br>记录值： 自己的github仓库地址<br>TTL： 10分钟</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTA4ED.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>接下来需要在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：name.com<br><img src="https://s1.ax1x.com/2018/11/06/iTE1r6.png" alt><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/11/06/iTEJaD.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol><p>最后重新部署你的博客<br>hexo clean # 清理<br>hexo g<br>hexo d<br>通过你自己的域名访问你的博客吧！</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h1><p>Hexo的配置文件设置及themes模板主题修改在下一篇文章当中。<br>感谢你的阅读，文章用于个人学习记录。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;&lt;strong&gt;环境搭建&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;Node-js&quot;&gt;&lt;a href=&quot;#Node-js&quot; class=&quot;heade
      
    
    </summary>
    
    
  </entry>
  
</feed>
