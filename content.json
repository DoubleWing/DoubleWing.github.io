[{"title":"红黑树","date":"2019-10-21T05:55:33.000Z","path":"/posts/undefined/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"B+树","date":"2019-10-21T05:55:06.000Z","path":"/posts/17426722/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"B树","date":"2019-10-21T05:54:44.000Z","path":"/posts/9439fc83/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"查找  树","slug":"查找-树","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/查找-树/"}]},{"title":"平衡二叉树","date":"2019-10-21T05:54:15.000Z","path":"/posts/4263f441/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"二叉排序树","date":"2019-10-21T05:53:41.000Z","path":"/posts/e5052ecb/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"折半查找","date":"2019-10-21T05:52:53.000Z","path":"/posts/8dbf9480/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"顺序查找","date":"2019-10-21T05:52:07.000Z","path":"/posts/cc0ea54c/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"较复杂的排序算法","date":"2019-10-21T04:25:27.000Z","path":"/posts/d20d6597/","text":"交换类排序-快速排序选择类排序-堆排序归并类排序-二路归并排序分配类排序-链式基数排序外部排序-置换选择排序 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/算法/"}]},{"title":"什么是uipath","date":"2019-10-21T03:12:26.000Z","path":"/posts/ed117eeb/","text":"UiPath一家机器人自动化的国际大公司，旗下产品uipath studio、uipath center、uipath robot都是关于RPA流程开发的工具 了解途径前几日，在36氪上看到前沿信息机器人自动化等等，觉得高大上，感觉是Al的落实项目，随机开始搜索信息关注此行业，从官网到QQ群到微信群再到论坛，无疑此为新型的行业，但是运用的是无编程技术主要是对于业务的了解情况以及思维逻辑和流程图设计，应该划分为业务部分。 uipath 架构打开uipath官网 ，了解其架构体系为： Studio（编辑器）—— 如各个编译平台一样，uipathStudio 是RPA流程开发工具 Ochestrator（中控/web平台）—— 管理所有的流程机器人、以及报表显示，及其他远程控制操作 类似阿里云平台 RoBots（机器人（脚本））——机器人安装到不同的电脑中，直接运行开发好的RPA流程，（有两种触发方式1.人机互动，手动才能触发2.VM虚拟机中固定时间自动触发） 应用于 金融行业（繁杂的业务逻辑，使用简单的机器人代替人工是不错的方案） 系统陈旧的企业（通过机器人完成业务逻辑，节约再开发再更新的成本） 国外RPA厂商uipath、buleprime、AA（简写）、NICE等 国内厂商艺赛旗、UiBot、达观数据等 总结经过三天的学习和探索，考取了uibot的认证工程师（其实是20分钟，不需要编程能力（笑），我认为这个行业对于计算机专业的专业编程人员来说不是一种系统学习知识的过程，其中是Excel、VBA、Python、Java、数据库、网络的零星知识点大集合，其中大量的业务逻辑用在UI自动化上，所以根据自己的学习路线应该了解uipath前沿信息，其技能很有可能人人都会用提前了解一下，要去真正的学习有门槛有难度的技术类似于AL、人工智能（我并不认为我能学会（哭） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/前沿资讯/"}]},{"title":"Java集合框架","date":"2019-06-26T04:32:24.000Z","path":"/posts/9753a2e/","text":"Java集合框架图 集合框架体系图 ArrayList描述ArrayList是一个Java容器类动态数组结构,看一下ArrayList的主要继承关系 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable 通过源码得知这些接口： List接口表明ArrayList是List的一种表现形式 RandomAccess接口表明ArrayList支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能 Cloneable接口表明必须实现clone()方法，clone()方法可以直接引用父类的clone()方法 Serializable接口表面可以使用Java默认的序列化机制，允许javabean序列化类图 常用方法 关键字 简介 add 增加 contains 判断是否存在 get 获取指定位置的对象 indexOf 获取对象所处的位置 remove 删除 set 替换 size 获取大小 toArray 转换为数组 addAll 把另一个容器所有对象都加进来 clear 清空 使用实例VectorLinkedListHashSetHashTableHashMap二叉树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"集合框架","slug":"集合框架","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/集合框架/"}]},{"title":"散列(hash)学习","date":"2019-05-01T08:27:20.000Z","path":"/posts/4cba6a27/","text":"散列(hash)散列或者说哈希，通过学习我知道：是一种将元素通过散列函数H（）转化为整数，使得整数可以尽量唯一地代表这个元素那么可以用key代表元素未转化，使用H(key)代表转化后的整数 散列函数 直接定址法恒等变换或是线性变换，即直接使用key作为数组下标，H（key）= a*key+b； 平方取中法使用KEY^2的中间若干位来作为hash值，H（key）= key^2的中间几位； 除留余数法把key除以一个数mod所得到的余数作为hash值，H（key）= key % mod ； 冲突我们发现有时候函数并不能代表一个值，通过除留余数法我们可能出现两个不同的key同时取余出相同的哈希值H（key），这时候就产生了冲突。 解决冲突的方法 线性探查法（Linear Probing）当出现冲突时，就检查下一个位置哈希值H（key）+1的位置是否被占用，没有就使用；如果仍然被占用就继续往下查找直到表最大，超过表长返回表的首位继续查找，如此循环；不过此方法效率低下，容易出现连续的被占用情况。 平方探查法（Quadratic Probing）为了避免反复查找位置，可以使用平方顺序进行查找，检查下一个位置H（key）+1^2，H（key）-1^2，H（key）+2^2，H（key）-2^2，H(key)+3^2,H(key+3^2……；当H（key）+k^2大于表长，则使用H（key）+k^2 %表长，H（key）-k^2小于0，则使用（（H(key)-k^2）%表长+表长）%表长，得到一个非负数的哈希值； 链地址法（拉链法）将所有hash值相同的key连接成一个单链表，其中的List[h]存放H（key）= h的一条单链表，当冲突发生时就遍历链表来寻找所有H（key） = h的key； 字符串hash前面的方法都是基于key为整数，那么当想使用一个hash尽可能代表一个字符串就需要其他的方法。可以浅显的理解字符串是数字、字母、特殊字符组成的，那么字符串随机组合分为七种。 扩展 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"哈希","slug":"哈希","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/哈希/"}]},{"title":"基础的排序算法","date":"2019-04-30T05:12:41.000Z","path":"/posts/4c06727b/","text":"算法复杂度 一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。 算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。 时间复杂度 一个算法中的语句执行次数。记为T(n),n称为问题的规模;若存在某个函数f(n)，当 n –> ∞时，T(n) / f(n) 为不等于0的常数，则称f(n)是T(n)的同数量级函数。记为T(n) = O(f(n))；称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。 常见的时间复杂度 常数阶 对数阶 线性阶 线性对数阶 平方阶 立方阶 K次方阶 指数阶 O(1) O(log2^n) O(n) O(nlog2^n) O(n^2) O(n^3) O(n^k) O(2^n) 随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 空间复杂度一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。 存储算法本身所占用的存储空间 算法的输入输出数据所占用的存储空间 算法在运行过程中临时占用的存储空间 冒泡排序冒泡排序是最基础的一种排序算法，让序列元素像汽泡一样”浮”上来冒泡排序本质在于交换元素，每次判断两个相邻元素的大小交换位置，直到剩余元素为0时。 算法步骤 比较相邻的元素。如果第一个比第二个大，则交换 整个过程进行n个元素-1次代码示例1234567891011121314151617181920212223int main(){//定义一个数组int a[10] = {2,0,1,9,4,3,0};//遍历n-1数组for (int i =0;i","tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/算法/"}]},{"title":"理解学习MySQL","date":"2018-12-01T07:25:27.000Z","path":"/posts/993e51d1/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"测试","date":"2018-11-04T12:44:59.000Z","path":"/posts/24d91ba1/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"hexo+github搭建个人博客教程","date":"2018-11-04T06:57:32.000Z","path":"/posts/6688b830/","text":"环境搭建Node.js 下载并安装Node.js 官网： http://nodejs.org/download/ 安装的时候Custom Setup选择第一个，安装完成。 Git下载安装及其配置 下载并安装Git 官网: https://git-scm.com/downloads 安装Git一路Next即可,Git安装完成. Git简单的教程请看廖雪峰的官方网:https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 安装并启动Hexo 在自己的本地磁盘中手动新建一个Hexo文件夹来存储本地文件。 到你新建的Hexo根目录右键选择 Git Bash Here 在git命令框安装Hexo，输入命令npm install -g hexo 安装完成后，初始化hexo命令:hexo init 启动hexo服务命令：npm install –>hexo s –>hexo clean –>hexo g –>hexo d hexo s 命令部署本地服务器浏览器输入http://localhost:4000可访问到初始页面 如果部署提示找不到git解决办法：在Hexo 3.0版本后deploy git 被分开的，所以需要安装。安装命令如下:npm install hexo-deployer-git --save安装好后再尝试一下重新部署就ok。 如果下载速度缓慢可以配置全局配置设置到淘宝源: 命令如下:npm config set registry https://registry.npm.taobao.org Github相关注册github的账号 创建一个新的仓库 仓库名必须遵守相应格式：username.github.io 这样子在访问主页的时候直接用 username.github.io 就能访问. 现在需要把你电脑里的clone到github仓库就需要git来帮忙了 设置Git的姓名和邮箱命令： git config --global user.name \"your_name\"git config --global user.email \"your_email\" 添加SSH key为了每次提交到github不需要重复输入账号密码，所以要设置ssh密钥，github连接仓库是由ssh密钥认证的,所以要添加自己的密钥进去 输入以下命令：ssh-keygen -t rsa -C \"your_email\"回车输入密码可继续三次回车跳过 在/Users/your_user_directory/.ssh/x下生成了私有密钥id_rsa和公开密钥id_rsa.pub》选择公有密钥用记事本打开 复制公钥内容 进入github设置中的ssh设置 新建一个ssh-key，Title随便取一个，粘贴刚复制的key，保存 最后验证是否添加成功返回到hexo文件夹打开git bash命令行，输入命令：ssh -T git@github.com看到这段话说明成功连接到你的github。浏览博客 hexo s (hexo sever=hexo s)一般用简写方便使用,打开本地服务器，方便发布前的调试。 hexo g (hexo generate=hexo g)一般用简写，是生成静态文件的命令。 hexo d (hexo deploy=hexo d)也是简写，部署之前预先生成静态文件 更多指令请看官方文档：https://hexo.io/zh-cn/docs/commands 浏览器中输入http://githubname.github.io 就可以看到hexo博客了!!!。 域名设置 购买域名 去阿里云或者其他域名网站选择购买域名，这里提供几个域名站的连接： https://sg.godaddy.com/zh/ #Godady https://wanwang.aliyun.com/ #阿里云 https://dnspod.cloud.tencent.com/ #腾讯云 设置域名解析 通过域名解析将我们的GitHub主页的域名解析到我们自己买的域名上面来，这样我们就可以通过我们自己的域名来访问我们的博客了 我是使用的阿里云解析，登陆域名控制台,看到你的域名后点击解析 记录类型为：CNAME记录两个值：@和www记录值： 自己的github仓库地址TTL： 10分钟 接下来需要在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：name.com 最后重新部署你的博客hexo clean # 清理hexo ghexo d通过你自己的域名访问你的博客吧！ 最后Hexo的配置文件设置及themes模板主题修改在下一篇文章当中。感谢你的阅读，文章用于个人学习记录。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]}]