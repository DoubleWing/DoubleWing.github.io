[{"title":"大数据Hadoop的环境搭建及应用实践（*毕业设计*）（1）","date":"2019-10-29T08:25:27.000Z","path":"/posts/42229cfc/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"golang编写聊天小程序demo","date":"2019-10-29T08:19:56.000Z","path":"/posts/cf527c99/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"go的http标准库","date":"2019-10-27T09:42:06.000Z","path":"/posts/8b4fc6ac/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"goroutine（一）","date":"2019-10-27T09:38:33.000Z","path":"/posts/ef415e9f/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"Go的资源管理与出错处理","date":"2019-10-27T09:36:26.000Z","path":"/posts/77741060/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"Docker初步使用及命令","date":"2019-10-27T09:27:14.000Z","path":"/posts/d33e3198/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"简单理解Docker和Kubernetes","date":"2019-10-27T09:26:36.000Z","path":"/posts/9afe7030/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"红黑树","date":"2019-10-21T05:55:33.000Z","path":"/posts/undefined/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"树","slug":"树","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/树/"},{"name":"查找算法","slug":"查找算法","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/查找算法/"}]},{"title":"B+树","date":"2019-10-21T05:55:06.000Z","path":"/posts/17426722/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"树","slug":"树","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/树/"},{"name":"查找算法","slug":"查找算法","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/查找算法/"}]},{"title":"B树","date":"2019-10-21T05:54:44.000Z","path":"/posts/9439fc83/","text":"B树（多路查找树）B树（B-tree）是一种平衡的多路查找树。节点最大的孩子数目称为B树的阶（order） B树的结构 如果根节点不是叶子节点，则其至少有两棵子树 每一个非根节点的分支节点都有k-1个元素和k个孩子，其中[m/2] { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"查找","slug":"查找","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/查找/"},{"name":"树","slug":"树","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/树/"}]},{"title":"二叉排序树","date":"2019-10-21T05:53:41.000Z","path":"/posts/e5052ecb/","text":"二叉排序树二叉排序树（Binary Sort Tree）,又叫二叉查找树。它是一棵空树或者是具有以下性质的数 左子树不为空，左子树所有节点的值均小于自身根节点的值 右子树不为空，右子树所有节点的值均大于自身根节点的值 左右子树也是二叉排序树 二叉排序树-查找 递归查找二叉排序树 若查找成功则指针指向该元素节点true 否则指针指向查找路径上访问的最后一个节点返回false 算法实现123456789101112131415161718// SearchBST为递归函数,lchild为左孩子,rchild为右孩子Status SearchBST(BiTree T,int key,BiTree f,BiTree *p){ if(!T) { *p = f; return FALSE; } else if (key==T->data){ *p = T; return TRUE; } else if (keydata){ return SearchBST(T->lchild,key,T,p); else return SearchBST(T->rchild,key,T,p); }} 算法分析 二叉排序树的查找运用了构造二叉树的特性，节点中满足一定的次序关系即：左子树节点一定比其双亲节点小，右子树节点一定比其双亲节点大 最少查找为1 最多查找为二叉排序树的深度 二叉排序树的查找性能取决于二叉排序树的形状（深度） 算法复杂度 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"树","slug":"树","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/树/"},{"name":"查找算法","slug":"查找算法","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/查找算法/"}]},{"title":"折半查找","date":"2019-10-21T05:52:53.000Z","path":"/posts/8dbf9480/","text":"折半查找折半查找（Binary Search）技术，又称为二分查找，其前提是线性表中的记录有序，线性表必须采用线性存储。 折半查找的思想 取中间数字作为比较对象，若给定值与中间记录的关键字相等，则查找成功； 若给定值小于中间数字，则在左半区进行查找； 若给定值大于中间记录的关键字，则在右半区进行查找 不断重复上述步骤，直到找到——查找成功或查找区域无记录——查找失败算法实现12345678910111213141516int Binary_Search(int *a,int n, int key){ int low ,high,mid; low =l; high = n; while(lwo mid = (low+high) /2; if(key high=mid-1； else if (key>a[mid]) low=mid+1; else return mid; } return 0;} { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"查找","slug":"查找","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/查找/"},{"name":"线性表","slug":"线性表","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/线性表/"}]},{"title":"顺序查找","date":"2019-10-21T05:52:07.000Z","path":"/posts/cc0ea54c/","text":"顺序查找顺序查找（Sequential Search）又叫做线性查找，是基本的查找技术 线性查找的思想 从表开始的第一个或最后一个开始，逐个进行记录的关键字和给与的定值进行比较 若相同，则查找成功 若遍历全表全部不同则查找失败 算法实现12345678910/*a为数组，n为查找的数组长度，key为查找的关键字*/int Sequential Search(int *a,int n,int key){ int i; for(i=1;i if (a[i]==key) return i; } return 0;} { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"查找","slug":"查找","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/查找/"},{"name":"线性表","slug":"线性表","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/线性表/"}]},{"title":"较复杂的排序算法","date":"2019-10-21T04:25:27.000Z","path":"/posts/d20d6597/","text":"交换类排序-快速排序可以理解为划分交换排序几乎最快的排序方法。（分治的策略） 分治法的基本思想将原有问题分解为若干个规模更小但结构与原问题相似的自问题，递归地解决这些子问题，然后将这些子问题的解组合为原问题的解 算法步骤 从一个待排序列中任意选择一个记录 以该记录的关键字作为“枢纽” 凡是关键字小于枢纽的记录均移动至该记录之前；反之，移动至该记录之后 一趟排序后，分割成左右两个子序列，再对两个子序列中进行快排 代码示例123456789101112131415161718192021222324int QKpass(RecordList L,int low,int high){ L.r[0] = L.r[low]; while(low while(low=L.r[0].key){ --high; } L.r[low] = L.r[high] ; while(lowhigh){ pos=QKpass(L,low,high); QKSort(L,low,pos-1); QKSort(l,POS+1,high); }}=1;i--){ HeapAdjust(L,i,L.length); }}//堆排序void HeapSort(RecordList L){ CreatHeap(L); for(i=L.length;i>=2;i--){ L.r[0] = L.r[1]; L.r[1] = L.r[i]; L.r[i] = L.r[0]; HeapAdjust(L,1,i-1); }} { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/排序算法/"}]},{"title":"什么是uipath","date":"2019-10-21T03:12:26.000Z","path":"/posts/ed117eeb/","text":"UiPath一家机器人自动化的国际大公司，旗下产品uipath studio、uipath center、uipath robot都是关于RPA流程开发的工具 了解途径前几日，在36氪上看到前沿信息机器人自动化等等，觉得高大上，感觉是Al的落实项目，随机开始搜索信息关注此行业，从官网到QQ群到微信群再到论坛，无疑此为新型的行业，但是运用的是无编程技术主要是对于业务的了解情况以及思维逻辑和流程图设计，应该划分为业务部分。 uipath 架构打开uipath官网 ，了解其架构体系为： Studio（编辑器）—— 如各个编译平台一样，uipathStudio 是RPA流程开发工具 Ochestrator（中控/web平台）—— 管理所有的流程机器人、以及报表显示，及其他远程控制操作 类似阿里云平台 RoBots（机器人（脚本））——机器人安装到不同的电脑中，直接运行开发好的RPA流程，（有两种触发方式1.人机互动，手动才能触发2.VM虚拟机中固定时间自动触发） 应用于 金融行业（繁杂的业务逻辑，使用简单的机器人代替人工是不错的方案） 系统陈旧的企业（通过机器人完成业务逻辑，节约再开发再更新的成本） 国外RPA厂商uipath、buleprime、AA（简写）、NICE等 国内厂商艺赛旗、UiBot、达观数据等 总结经过三天的学习和探索，考取了uibot的认证工程师（其实是20分钟，不需要编程能力（笑），我认为这个行业对于计算机专业的专业编程人员来说不是一种系统学习知识的过程，其中是Excel、VBA、Python、Java、数据库、网络的零星知识点大集合，其中大量的业务逻辑用在UI自动化上，所以根据自己的学习路线应该了解uipath前沿信息，其技能很有可能人人都会用提前了解一下，要去真正的学习有门槛有难度的技术类似于AL、人工智能（我并不认为我能学会（哭） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/前沿资讯/"}]},{"title":"Java集合框架","date":"2019-06-26T04:32:24.000Z","path":"/posts/9753a2e/","text":"Java集合框架图 集合框架体系图 ArrayList描述ArrayList是一个Java容器类动态数组结构,看一下ArrayList的主要继承关系 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable 通过源码得知这些接口： List接口表明ArrayList是List的一种表现形式 RandomAccess接口表明ArrayList支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能 Cloneable接口表明必须实现clone()方法，clone()方法可以直接引用父类的clone()方法 Serializable接口表面可以使用Java默认的序列化机制，允许javabean序列化类图 常用方法 关键字 简介 add 增加 contains 判断是否存在 get 获取指定位置的对象 indexOf 获取对象所处的位置 remove 删除 set 替换 size 获取大小 toArray 转换为数组 addAll 把另一个容器所有对象都加进来 clear 清空 使用实例VectorLinkedListHashSetHashTableHashMap二叉树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"集合框架","slug":"集合框架","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/集合框架/"}]},{"title":"散列(hash)学习","date":"2019-05-01T08:27:20.000Z","path":"/posts/4cba6a27/","text":"散列(hash)散列或者说哈希，通过学习我知道：是一种将元素通过散列函数H（）转化为整数，使得整数可以尽量唯一地代表这个元素那么可以用key代表元素未转化，使用H(key)代表转化后的整数 散列函数 直接定址法恒等变换或是线性变换，即直接使用key作为数组下标，H（key）= a*key+b； 平方取中法使用KEY^2的中间若干位来作为hash值，H（key）= key^2的中间几位； 除留余数法把key除以一个数mod所得到的余数作为hash值，H（key）= key % mod ； 冲突我们发现有时候函数并不能代表一个值，通过除留余数法我们可能出现两个不同的key同时取余出相同的哈希值H（key），这时候就产生了冲突。 解决冲突的方法 线性探查法（Linear Probing）当出现冲突时，就检查下一个位置哈希值H（key）+1的位置是否被占用，没有就使用；如果仍然被占用就继续往下查找直到表最大，超过表长返回表的首位继续查找，如此循环；不过此方法效率低下，容易出现连续的被占用情况。 平方探查法（Quadratic Probing）为了避免反复查找位置，可以使用平方顺序进行查找，检查下一个位置H（key）+1^2，H（key）-1^2，H（key）+2^2，H（key）-2^2，H(key)+3^2,H(key+3^2……；当H（key）+k^2大于表长，则使用H（key）+k^2 %表长，H（key）-k^2小于0，则使用（（H(key)-k^2）%表长+表长）%表长，得到一个非负数的哈希值； 链地址法（拉链法）将所有hash值相同的key连接成一个单链表，其中的List[h]存放H（key）= h的一条单链表，当冲突发生时就遍历链表来寻找所有H（key） = h的key； 字符串hash前面的方法都是基于key为整数，那么当想使用一个hash尽可能代表一个字符串就需要其他的方法。可以浅显的理解字符串是数字、字母、特殊字符组成的，那么字符串随机组合分为七种。 扩展 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"查找","slug":"查找","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/查找/"},{"name":"哈希","slug":"哈希","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/哈希/"}]},{"title":"基础的排序算法","date":"2019-04-30T05:12:41.000Z","path":"/posts/4c06727b/","text":"算法复杂度 一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。 算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。 时间复杂度 一个算法中的语句执行次数。记为T(n),n称为问题的规模;若存在某个函数f(n)，当 n –> ∞时，T(n) / f(n) 为不等于0的常数，则称f(n)是T(n)的同数量级函数。记为T(n) = O(f(n))；称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。 常见的时间复杂度 常数阶 对数阶 线性阶 线性对数阶 平方阶 立方阶 K次方阶 指数阶 O(1) O(log2^n) O(n) O(nlog2^n) O(n^2) O(n^3) O(n^k) O(2^n) 随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 空间复杂度一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。 存储算法本身所占用的存储空间 算法的输入输出数据所占用的存储空间 算法在运行过程中临时占用的存储空间 冒泡排序冒泡排序是最基础的一种排序算法，让序列元素像汽泡一样”浮”上来冒泡排序本质在于交换元素，每次判断两个相邻元素的大小交换位置，直到剩余元素为0时。 算法步骤 比较相邻的元素。如果第一个比第二个大，则交换 整个过程进行n个元素-1次代码示例1234567891011121314151617181920212223int main(){//定义一个数组int a[10] = {2,0,1,9,4,3,0};//遍历n-1数组for (int i =0;i //第i次从a[0]~a[n-i]与他们下一个数比较 for(int j=0;j //判断相邻大小进行交换 if(a[j]>a[j+1]){ //中间变量temp int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } }}//打印输出for(int i=0;i printf(\"%d\",a[i]);}return 0;}","tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/排序算法/"}]},{"title":"golang编写日志存储及可视化demo","date":"2019-03-04T07:20:37.000Z","path":"/posts/a5aa196c/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"MySQL基础知识","date":"2018-12-01T07:25:27.000Z","path":"/posts/993e51d1/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/MySQL/"},{"name":"基础","slug":"基础","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/基础/"}]},{"title":"测试","date":"2018-11-04T12:44:59.000Z","path":"/posts/24d91ba1/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"hexo+github搭建个人博客教程","date":"2018-11-04T06:57:32.000Z","path":"/posts/6688b830/","text":"环境搭建Node.js 下载并安装Node.js 官网： http://nodejs.org/download/ 安装的时候Custom Setup选择第一个，安装完成。 Git下载安装及其配置 下载并安装Git 官网: https://git-scm.com/downloads 安装Git一路Next即可,Git安装完成. Git简单的教程请看廖雪峰的官方网:https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 安装并启动Hexo 在自己的本地磁盘中手动新建一个Hexo文件夹来存储本地文件。 到你新建的Hexo根目录右键选择 Git Bash Here 在git命令框安装Hexo，输入命令npm install -g hexo 安装完成后，初始化hexo命令:hexo init 启动hexo服务命令：npm install –>hexo s –>hexo clean –>hexo g –>hexo d hexo s 命令部署本地服务器浏览器输入http://localhost:4000可访问到初始页面 如果部署提示找不到git解决办法：在Hexo 3.0版本后deploy git 被分开的，所以需要安装。安装命令如下:npm install hexo-deployer-git --save安装好后再尝试一下重新部署就ok。 如果下载速度缓慢可以配置全局配置设置到淘宝源: 命令如下:npm config set registry https://registry.npm.taobao.org Github相关注册github的账号 创建一个新的仓库 仓库名必须遵守相应格式：username.github.io 这样子在访问主页的时候直接用 username.github.io 就能访问. 现在需要把你电脑里的clone到github仓库就需要git来帮忙了 设置Git的姓名和邮箱命令： git config --global user.name \"your_name\"git config --global user.email \"your_email\" 添加SSH key为了每次提交到github不需要重复输入账号密码，所以要设置ssh密钥，github连接仓库是由ssh密钥认证的,所以要添加自己的密钥进去 输入以下命令：ssh-keygen -t rsa -C \"your_email\"回车输入密码可继续三次回车跳过 在/Users/your_user_directory/.ssh/x下生成了私有密钥id_rsa和公开密钥id_rsa.pub》选择公有密钥用记事本打开 复制公钥内容 进入github设置中的ssh设置 新建一个ssh-key，Title随便取一个，粘贴刚复制的key，保存 最后验证是否添加成功返回到hexo文件夹打开git bash命令行，输入命令：ssh -T git@github.com看到这段话说明成功连接到你的github。浏览博客 hexo s (hexo sever=hexo s)一般用简写方便使用,打开本地服务器，方便发布前的调试。 hexo g (hexo generate=hexo g)一般用简写，是生成静态文件的命令。 hexo d (hexo deploy=hexo d)也是简写，部署之前预先生成静态文件 更多指令请看官方文档：https://hexo.io/zh-cn/docs/commands 浏览器中输入http://githubname.github.io 就可以看到hexo博客了!!!。 域名设置 购买域名 去阿里云或者其他域名网站选择购买域名，这里提供几个域名站的连接： https://sg.godaddy.com/zh/ #Godady https://wanwang.aliyun.com/ #阿里云 https://dnspod.cloud.tencent.com/ #腾讯云 设置域名解析 通过域名解析将我们的GitHub主页的域名解析到我们自己买的域名上面来，这样我们就可以通过我们自己的域名来访问我们的博客了 我是使用的阿里云解析，登陆域名控制台,看到你的域名后点击解析 记录类型为：CNAME记录两个值：@和www记录值： 自己的github仓库地址TTL： 10分钟 接下来需要在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：name.com 最后重新部署你的博客hexo clean # 清理hexo ghexo d通过你自己的域名访问你的博客吧！ 最后Hexo的配置文件设置及themes模板主题修改在下一篇文章当中。感谢你的阅读，文章用于个人学习记录。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"搭建","slug":"搭建","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/搭建/"}]},{"title":"平衡二叉树","date":"2018-10-21T05:54:15.000Z","path":"/posts/4263f441/","text":"平衡二叉树平衡二叉树（AVL树）是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1，是一种高平衡的二叉排序树 平衡因子(BF) 将二叉排序树上的节点的左子树深度减去右子树深度的值叫做平衡因子 平衡二叉树的平衡因子只能为 -1,0,1 二叉树上若有一个节点的平衡因子的绝对值大于1，则不平衡 最小不平衡子树 距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树 图片示例构建平衡二叉树 在构建二叉排序树的过程中，每当插入一个节点时，先检查是否因插入而破坏了树的平衡性 若没有破坏，则仍为平衡二叉树 若有，则调整最小不平衡子树中各节点之间的链接关系，进行相应的旋转，使之成为新的平衡子树 构建示例算法实现结构定义：1234567typedef struct BiTNode{ int data;//节点数据 int bf;//平衡因子 struct BiTNode *lchild, *rchild;//左右孩子指针}BiTNode , *BiTree; 右旋操作:123456789//以p为根的二叉排序树void Right_Rotate(BiTree *p){ BiTree L; L=(*p) ->lchild; (*p) ->lchild= L->rchild; L->rchild=(*p); *p=L;} 左旋操作：12345678void Left_Rotate(BiTree *p){ BiTree R; R= (*p) -> rchild; (*p)->rchild=R->lchild; R -> lchild=(*p); *p=R;} 左平衡旋转处理：1234567891011121314151617181920212223242526272829303132333435363738#define LH +1 //左高#define EH 0 //等高#define RH -1 //右高void RightBalance(BiTree *T){ BiTree L,Lr; L=(*T)->lchild; switch(L->bf)//平衡度处理 { /*新节点插入在T的左孩子的左子树上*/ case LH: (*T) ->bf=L->bf=EH; Right_Rotate(T); break; /*新节点插入在T的左孩子的右子树上*/ case RH: Lr=L->rchild; /*修改T及其左孩子的平衡因子*/ switch(Lr->bf) { case LH: (*T)->bf=RH; L->bf=EH; break; case EH: (*T)->bf=L->bf=EH; break; case RH: (*T)->bf=EH L->bf=LH; break; } Lr->bf=EH; Left_Rotate(&(*T)->lchild); Right_Rotate(T); }} 右平衡旋转处理：1234567891011121314151617181920212223242526272829303132333435363738#define LH +1 //左高#define EH 0 //等高#define RH -1 //右高void LeftBalance(BiTree *T){ BiTree R,Rl; R=(*T)->rchild; switch(R->bf)//平衡度处理 { /*新节点插入在T的右孩子的右子树上*/ case RH: (*T) ->bf=R->bf=EH; Left_Rotate(T); break; /*新节点插入在T的右孩子的左子树上*/ case LH: Rl=R->lchild; /*修改T及其右孩子的平衡因子*/ switch(Rl->bf) { case RH: (*T)->bf=LH; R->bf=EH; break; case EH: (*T)->bf=R->bf=EH; break; case LH: (*T)->bf=EH R->bf=RH; break; } Rl->bf=EH; Right_Rotate(&(*T)->rchild); Left_Rotate(T); }} 主函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*int类型e表示新节点，布尔类型*taller表示T的深度*/Status InsertAVL(BiTree *T,int e,Status *taller){ if(!*T) { /*插入新节点，树\"长高\",置taller为TRUE*/ *T=(BiTree)malloc(sizeof(BiTNode)); (*T)->data=e; (*T)->lchild-(*T)->rchild=NULL; (*T)->bf=EH; *taller=TRUE; } else { if (e==(*T)->data) { /*树中已存在和e有相同关键字的节点则不再插入*/ *taller=FALSE; return FALSE; } if (edata) { /*继续在T的左子树中进行搜索*/ if(!InsertAVL(&(*T)->lchild,e,taller)) return FALSE; //未插入 //已插入到T的左子树且左子树深度增加 if(*taller) { switch((*T)->bf)//检查T的平衡度 { case LH: LeftBalance(T); *taller=FALSE; break; case EH: (*T)->bf=LH; *taller=TRUE; break; case RH: (*T)->bf=EH; *taller=FALSE; break; } } } else { /*继续在T的右子树中进行搜索*/ if(!InsertAVL(&(*T)->rchild,e,taller)) return FALSE;//未插入 /*已插入到T的右子树且深度增加*/ if(*taller) { switch((*T)->bf)//检查平衡度 { case LH: (*T)->bf=EH; *taller=FALSE; break; case EH: (*T)->bf=RH; *taller=TRUE; break; case RH: RightBanlance(T); *taller=FALSE; break; } } } } return TRUE;} 构建平衡二叉树:12345678int i;int a[10]={3,2,1,4,5,6,7,10,9,8}BiTree T=NUll;Status taller;for (i=0;i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"查找","slug":"查找","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/查找/"},{"name":"树","slug":"树","permalink":"https://github.com/DoubleWing/DoubleWing.github.io/tags/树/"}]},{"title":"golang编写短连接生成器","date":"2018-10-20T14:10:59.000Z","path":"/posts/undefined/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"golang编写单机爬虫（一）","date":"2018-08-29T05:21:09.000Z","path":"/posts/63cff225/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"Channel（一）","date":"2018-08-17T13:19:22.000Z","path":"/posts/49f8918a/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]}]